# Subconjuntos
En R, podemos obtener subconjuntos de nuestras estructuras de datos. Es decir, podemos extraer partes de una estructura de datos (nuestro conjunto).

Hacemos esto para seleccionar datos que tienen características específicas, por ejemplo, todos los valores mayores a cierto número o aquellos que coinciden exactamente con un valor de nuestro interés.

Para realizar esta operación haremos uso de índices, operadores lógicos y álgebra Booleana. Algunos procedimientos para obtener subconjuntos pueden usarse con cualquier estructura de datos, mientras que otras sólo funcionan con algunas de ellas.

En este capítulo revisaremos cómo extraer subconjuntos de vectores, matrices, data frames y listas, usando índices, nombres y condicionales.

## Índices
Usar índices para obtener subconjuntos es el procedimiento más universal en R, pues funciona para todas las estructuras de datos.

Un índice en R representa una **posición**. Cuando usamos índices le pedimos a R que extraiga de una estructura los datos que se encuentran en una o varias posiciones específicas dentro de ella.

A diferencia de la mayoría de los lenguajes de programación, los índices en R empiezan en **1**, no en **0**. El índice del primer elemento de una estructura de datos siempre es 1, el segundo 2, y así sucesivamente.

Veamos un ejemplo para ilustrar lo anterior.

Creamos un vector que contiene los nombres de distintos niveles educativos. 
```{r vector_niveles, echo=TRUE}
nivel <- c("Preescolar", "Primaria", "Secundaria", "Educación Media Superior",
           "Educación Superior")

nivel
```

Este es un vector de largo igual a cinco.
```{r}
length(nivel)
```

¿Cómo obtendríamos el tercer elemento de este vector usando índices? ¿O del primer al cuarto elemento? ¿O el segundo y quinto elemento?

Para obtener subconjuntos con índices escribimos corchetes `[]` después del nombre de un objeto.  Dentro de los corchetes escribimos el o los números que corresponden a la posición que nos interesa extraer del objeto.

Por ejemplo:

* `objeto[3]`
* `lista[4:5]` 
* `dataframe[c(2, 7), ]`

Entonces, para extraer el tercer elemento de nuestro vector `nivel` hacemos lo siguiente.
```{r, echo=TRUE}
nivel[3]
```

Para extraer del primer al cuarto elemento de un vector, usamos un vector con una secuencia numérica del 1 al 4 creada con `:`.
```{r, echo=TRUE}
nivel[1:4]
```

Sin embargo, si intentamos extraer el segundo y quinto elemento del vector `nivel` corriendo lo siguiente, obtendremos un error.
```{r, echo = TRUE, error = TRUE}
nivel[2, 5]
```

¿Porqué no ha funcionado lo anterior? 

El mensaje de error nos da una pista muy importante. Al usar una coma dentro de los corchetes estamos dando la instrucción a R de buscar los índices solicitados en más de una dimensión. El número antes de la coma será buscado en la primera dimensión del objeto, y el segundo número, en su segunda dimensión.

Entonces, al llamar `nivel[2, 5]`, lo que estamos pidiendo es que R extraiga el elemento que se encuentra en la posición **2** de la primera dimensión del vector, y el elemento en la posición **5** de su segunda dimensión.  Como los vectores son unidimensionales, es imposible cumplir esta instrucción y se produce un error.

Recuerda que en R, un número sencillo es también un vector, por lo tanto, cuando escribimos `vector[3]`, en realidad estamos dando como índice un vector que contiene al número 3.

Por lo tanto, si deseamos extraer elementos en posiciones no consecutivas, debemos usar vectores generados con `c()`. De este modo damos un vector, de más de un número de largo al corchete, pero todos se encuentran en una misma dimensión.

Aplicando lo anterior, si escribimos dentro de los corchetes `c(2, 5)`, entonces tendremos éxito al extraer el segundo y quinto elemento de `nivel`.
```{r, echo=TRUE}
nivel[c(2, 5)]
```

Para estructuras de dos dimensiones, como són matrices y data frames, **el primer vector de un índice, antes de una coma, es la posición en los renglones y el segundo es la posición las columnas**. 

Obtener subconjuntos por renglones y columnas es un tipo de operación muy común al trabajar con data frames y matrices.

## Índices con data frames y matrices
Creamos un data frame llamado `mi_df`. 
```{r mi_df, echo=TRUE}
mi_df <- data.frame("nombre" = c("Armando", "Elsa", "Ignacio", "Olga"),
                    "edad" = c(20, 24, 22, 30),
                    "sexo" = c("H", "M", "M", "H"),
                    "grupo" = c(0, 1, 1, 0))

# Resultado
mi_df
```

Usamos `dim()` para confirmar que nuestro objeto tiene dos dimensiones: tres renglones y tres columnas.
```{r dim_mi_df, echo=TRUE}
dim(mi_df)
```

Si usamos un índice con un sólo número, extraemos una columna completa, con todos sus renglones.
```{r mi_df_columna}
mi_df[1]
```

Si usamos un vector, sin comas, obtenemos varias columnas.
```{r mi_df_doscol, echo=TRUE}
mi_df[c(1, 3)]
```

Al usar comas, el vector antes de la coma nos devolverá un renglón completo.

```{r, echo=TRUE}
mi_df[3,]
```

Nota que si dejamos vació el espacio después de la coma, se nos devuelven todas las columnas del data frame.

Si el espacio que dejamos vacío es el que se encuentra después de la coma, obtenemos columnas. Esto es equivalente a usar un solo vector dentro de los corchetes.
```{r columna_coma, echo=true}
mi_df[ ,1]
```

Al combinar índices para renglones y columnas, obtenemos los datos que se encuentran en una posición específica.

Por ejemplo, el dato en el tercer renglón y la tercer columna.
```{r, echo=TRUE}
mi_df[3, 3]
```

El segundo y tercer dato de la tercera columna.
```{r, echo = TRUE}
mi_df[2:3, 3]
```

El cuarto renglón de la tercera y cuarta columna.
```{r, echo = TRUE}
mi_df[4, 3:4]
```

También podemos usar vectores de más de un número. Por ejemplo, los datos en en el primer y segundo renglón, y en la segunda y cuarta columna.
```{r, echo=TRUE}
mi_df[1:2, c(2, 4)]
```

Por último, en todos los casos anteriores, hemos obtenido como resultado un data frame.

```{r, echo=TRUE}
sub_df <- mi_df[1:2, c(2, 4)]

class(sub_df)
```

### Índices inválidos
Si damos un índice inválido para las columnas, es decir, un número de columna que no exista, se nos devuelve un renglón.

Intentemos obtener la séptima columna de `mi_df`.
```{r, echo = TRUE, error=TRUE}
mi_df[7]
```

Sin embargo, para los renglones simplemente se nos devuelve `NA`.

```{r, echo = TRUE}
mi_df[7, ]
```

### Matrices
Todo lo anterior funciona de la misma manera para las matrices, con una excepción.

Si usamos como índice un sólo número, entonces obtendremos el valor que se encuentre en esa posición, contando celdas de arriba a abajo y de izquierda a derecha.

Creamos una matriz con 4 renglones y dos columnas.
```{r, echo=TRUE}
mi_matriz <- matrix(1:8, nrow = 4)

# Resultado
mi_matriz
```

Si damos como índice el número 8, R no intentará devolvernos la octava columna de la matriz, sino la octava celda.
```{r, echo=TRUE}
mi_matriz[8]
```

Fuera de este caso, los índices de renglones y columna tienen el mismo comportamiento que en un data frame.
```{r, echo=TRUE}
# Tercer renglón
mi_matriz[3, ]

# Segunda columna
mi_matriz[ ,2]

# Tercer renglón y segunda columna
mi_matriz[3, 2]
```

Nota que en este caso obtenemos vectores al extraer un subconjunto.

### Arrays
Para objetos de tres o más dimensiones se siguen las mismas reglas que con las matrices, aunque ya no es tan fácil hablar de renglones y columnas. 

Creamos un array de cuatro dimensiones.
```{r, echo=TRUE}
mi_array <- array(data = 1:16, dim = c(2, 2, 2, 2))
```

Veamos nuestro resultado y comprobamos con `dim()` su número de dimensiones.
```{r, echo=TRUE}
mi_array

# Comprobamos el número de dimensiones de nuestro objeto
dim(mi_array)
```

Intentemos extraer varios subconjuntos, sólo para ilustrar cómo funcionan los índices con arrays.
```{r}
mi_array[1, , , ]
mi_array[1, 2, , ]
mi_array[1, 2, 1, ]
mi_array[1, 2, 1, 2]
```

Nota que como resultados obtenemos matrices, a menos que hagamos una extraigamos el contenido de una sola celda.

## Subconjuntos por nombre
Un segundo método para extrar subconjuntos es usar los nombres de los elementos en una estructura de datos. Este forma de obtener subconjuntos es usada principalmente con data frames y listas. 

De manera similar a los índices, usamos corchetes cuadrados `[]` después del nombre de un objeto, pero en lugar de escribir un número, escribimos el nombre del elemento que deseamos extraer como una cadena de texto, es decir, entre comillas.

### Data frames
Los elementos de un data frame son sus columnas y cada una de ellas tiene un nombre, lo que estamos pidiendo a R con este método es que nos devuelva los elementos cuyo nombre coincida con el que hemos proporcionado

Para mostrar el uso de este método, utilizaremos el mismo data frame que en la sección anterior.

Si escribimos entre corchetes "nombre", obtendremos toda la columna **nombre**.
```{r, echo=TRUE}
mi_df["nombre"]
```

Al escribir "grupo", nos es devuelta toda la columna con ese nombre.
```{r, echo=TRUE}
mi_df["grupo"]
```

De igual manera que con los índices, al escribir una coma dentro de los corchetes, estamos pidiendo con ello extraer elementos en más de una dimensión. Lo que está antes escrito antes de la coma corresponde a renglones, y lo que está después, a columnas.

Si ejecutamos lo siguiente, obtendremos `NA` en lugar de obtener las columnas **edad** y **sexo**.
```{r, echo=TRUE}
mi_df["edad", "sexo"]
```

Lo anterior ocurre porque R intenta encontrar un renglón llamado "edad" y una columna llamada "sexo", al no encontrarlas, nos devuelve `NA`. Recuerda que aunque no es lo más común, los renglones de un data frame pueden tener nombres.

Al igual que con los índices, si damos el nombre de un renglón que existe, obtenemos `NA`. Es sólo al solicitar un nombre de columna no válido que se nos devuelve un error.

Pedimos un nombre de renglón inexistente y obtenemos `NA`.
```{r, echo =TRUE}
mi_df["localidad", ]
```

Pero si pedimos un nombre inválido de columna, nos es devuelto un error.
```{r, echo=TRUE, error=TRUE}
mi_df[, "localidad"]
```

Para extraer más de una columna, escribimos un vector de texto entre los corchetes.
Por ejemplo
```{r, echo = TRUE}
mi_df[c("edad", "sexo")]
```

Además, las columnas son devueltas en el orden que las pedimos, lo cual es conveniente cuando estamos procesando y recodificando datos.
```{r, echo=TRUE}
mi_df[c("sexo", "edad")]
```

### Listas
Para una lista, el procedimiento es prácticamente el mismo que para un data frame, pero en lugar de obtener columnas, obtenemos los elementos contenidos en ella.

La primera diferencia con los data frame es que, dado que las listas son unidimensionales, si usamos una coma dentro de los corchetes, nos será devuelto un error.

Creamos una lista llamada `mi_lista`.
```{r, echo=TRUE}
mi_lista <- list("uno" = 1, "dos" = "2", "tres" = as.factor(3), 
                 "cuatro" = c(1:4))
```

Intentamos obtener un subconjunto con una coma.
```{r, echo=TRUE}
mi_lista["uno", "dos"]
```

Si pedimos un nombre que no existe en la lista, se nos devuelve `NULL` en lugar de un error.
```{r, echo=TRUE}
mi_lista["cinco"]
```

Para todo lo demás, los nombres tienen el mismo comportamiento que para los data frames.

Extremos un elemento de la lista.
```{r, echo = TRUE}
mi_lista["dos"]
```

Extraemos más de un elemento de la lista.
```{r, echo=TRUE}
mi_lista[c("cuatro", "tres")]
```

### Usando el signo de dolar `$`
Otra manera en la que podemos extraer subconjuntos usando nombres, es con el signo de dólar `$`.

Para usar este método, escribir el signo `$` después del nombre de un objeto de la siguiente forma: `objeto$nombre`.

Este método permite extraer un sólo elemento a la vez y en para los data frame, el elemento extraido siempre será una columna.


Por ejemplo, 
```{r, echo = TRUE, error=TRUE}
# Esto funciona
mi_df$nombre

# Esto también funciona
mi_df$"nombre"

# Esto no funciona
mi_df$c("nombre", "edad")

```

Notarás que la salida al usar este método es diferente que si usamos corchetes. Si revisas la **Tarea 01**, verás más ejemplos de este comportamiento.

En pocas palabras, **distintos métodos para obtener subconjuntos pueden devolver resultados diferentes**. Más adelante en este documento veremos porqué ocurre esto 

** Nombres para extraer renglones
De igual manera que con los índices, si escribimos dentro de un corchete nombres separados por comas, R interpretará esto como que estamos buscando elementos en más de una dimensión.

En un data frame, el primer nombre corresponderá a renglones y el segundo a columnas. Esto funciona porque en un data frame los renglones también pueden tener nombre. 

En caso de que pidamos un nombre de renglón que no existe, nos es devuelto **NA**

Por ejemplo, en el conjunto de datos **iris** los nombres de los renglones son igual a su número de renglón.
```{r, echo=TRUE}
# Pedimos el renglón llamado "4"
iris["4", ]

# En este caso, lo anterior es equivalente a pedir el índice cuatro
iris[4, ]
```

Lo anterior nos permite extraer subconjuntos muy específicos de nuestros datos.
```{r, echo=TRUE}
iris["110", "Species"]

iris["15", c("Sepal.Length", "Sepal.Width")]

iris[c("88", "96"), c("Sepal.Length","Sepal.Width")]
```

## Subconjuntos por índice y nombre
Al extraer subconjuntos combinar índices con nombres dentro del mismo corchete.

Esta es una herramienta muy poderosa al manipular datos pues nos proporciona una flexibilidad para extrar subconjuntos.

Por supuesto, tenemos que seguir las reglas de ambos métodos.
```{r, echo=TRUE}
iris[5:6, "Species"]

iris["76", 2:3]

iris[c(1:2, 149:150), c("Petal.Width", "Species")]
```

Esto no funciona con las listas, Por ser estructuras de datos unidimensionales.


** Subconjuntos con su clase y tipo original: usando el signo de dólar $ y el corchete doble [[ ]]

¿Porqué llamar **mi_df["nombre"]** devuelve un resultado diferente de llamar **mi_df$nombre**?

```{r, echo = TRUE}
mi_df["nombre"]

mi_df$nombre
```

Para entender que está ocurriendo, recordemos que **un data frame está formado por vectores**. Estos vectores nunca dejan de ser vectores, aunque estén contenidos dentro de un data frame, por lo tanto, es posible extraerlos de esta estructura de datos.

Además, necesitamos entender que **cuando extraemos un subconjunto de un objeto usando corchetes, obtenemos como resultado un objeto de su misma clase**.

Esto suena a un trabalenguas, pero todo lo que quiere decir es que extraemos un subconjunto de una lista, obtenemos una lista; si lo hacemos de un data frame, obtenemos un data frame; y lo mismo para todas las estructuras de datos.

Esto lo podemos comprobar fácilmente usando la función **class( )**

```{r, echo = TRUE}
class(mi_df)

class(mi_df["nombre"])
```

Esto cambia cuando usamos el signo de dólar **$** para extraer un subconjunto. **Si usamos un signo de dolar, obtenemos un objeto de la misma clase y tipo que era ese elemento originalmente**. 

En el caso de un data frame, usar el signo de dólar siempre resulta en vectores atómicos.

```{r, echo = TRUE}
class(mi_df$nombre)

class(mi_df$edad)

class(mi_df$sexo)
```

Con las listas, podemos obtener objetos de cualquier clase y tipo.

```{r, echo=TRUE}
# Una lista con una matriz y un data frame.
mi_lista <- list("uno" = matrix(2:2, nrow = 2), 
              "dos" = data.frame("a" = 1:2, "b" = 3:4))

# Devuelve una lista
class(mi_lista["uno"])

# Devuelve una matriz
class(mi_lista$uno)

# Devuelve un data frame
class(mi_lista$dos)
```

Otra manera de extraer elementos de un objeto con su clase original es usar corchetes dobles **[[ ]]**. 

La ventaja de usar este método es que podemos usar índices y nombres dentro de los corchetes dobles, lo que nos da acceso a una mayor flexibilidad para extraer subconjuntos, además de que nos permite usarlos en estructuras de datos que tienen elementos sin nombre.

```{r, echo=TRUE}
mi_df[["edad"]]

mi_df[[2]]

mi_matriz <- matrix(1:9, nrow = 3, ncol = 3)

mi_matriz

mi_matriz[[1, 2]]
```

Sin embargo, no podemos usar vectores dentro los corchetes dobles para extraer subconjuntos, pues este método busca un elemento a la vez.

```{r, echo=TRUE, error=TRUE}
mi_matriz[[c(1, 3), 2]]
```

Obtener un objeto del tipo correcto al extraer un subconjunto es sumamente importante, en particular si deseamos usar este subconjunto para realizar otras operaciones.

Por ejemplo, si queremos obtener la media de la columna **Sepal.Width** del conjunto de datos iris, usamos la función **mean( )**. Sin embargo, esta función nos pide que demos como argumento un vector, de modo que debemos estar atentos a cómo extraemos la columna que nos interesa.

```{r, echo = TRUE}
# Esto no funciona, porque estamos extrayendo un data frame
mean(iris["Sepal.Width"])

# Esto sí funciona
mean(iris$Sepal.Width)

# Esto también funciona
mean(iris[["Sepal.Width"]])
```

## Subconjuntos de un data frame usando condicionales

Supongamos que nos interesa obtener un subconjunto de datos que cumplen con una o más condiciones específicas.

Por ejemplo, queremos obtener todos los datos de una encuesta que corresponden a mujeres, o a personas que viven en una entidad específica o que tienen un ingreso superior a la media.

Si tenemos columnas que contengan esa información en nuestro conjunto de datos, podemos extraer subconjuntos usando condicionales dentro de los corchetes.

Esta operación tiene la siguiente estructura.

** objeto[condicion, columnas_devueltas] **

Veamos un ejemplo.

Extraeremos del conjunto iris...

... todos los casos en los que el ancho del pétalo es mayor a 2. 

```{r, echo = TRUE}
iris[iris["Petal.Width"] > 2, ]
```

... todos los casos en los que la especie sea "setosa"

```{r}
iris[iris[["Species"]] == "setosa", ]
```

... la especie de los casos en que los que el ancho del sépalo sea menor a 3.

```{r}
iris[iris$Sepal.Width < 3, "Species"]
```

... el ancho y largo del pétalo de los casos en los que el largo del sépalo es mayor o igual a 7.2.

```{r}
iris[iris["Sepal.Length"] >= 7.2, c("Petal.Length", "Petal.Width")]
```

¿Qué es lo que está ocurriendo?

Dentro del corchete escribimos antes de una coma un subconjunto, al cual aplicamos una operación relacional. Todos los renglones en los que el resultado de esta operación sea **TRUE**, formarán parte de nuestro subconjunto.

Si no indicamos qué columnas queremos que se nos devuelvan, obtendremos todas. De esta manera podemos extraer subconjuntos que cumplen una condición, pero sólo para una columna específica.

Para entender porqué escribimos una operación relacional aplicada a un subconjunto dentro de los corchetes, nos conviene saber que las operaciones relacionales también se vectorizan.

Si al vector **iris$Petal.Width** aplicamos la operación **> 6**, esta se aplicará a todos sus elementos, devolviendo **TRUE** o **FALSE**, según corresponda.

```{r, echo = TRUE}
as.vector(iris["Petal.Width"] > 6)
```

Así, lo que pedimos antes de la coma dentro de un corchete, son todos los renglones para los que la condición es verdadera.

Si quisieras, podrías elegir manualmente renglones de un data frame usando TRUE y FALSE.
```{r, echo=TRUE}
# EL vector de datos lógicos se reciclará, así que obtendremos uno de cada cinco elementos
iris[c(TRUE, FALSE, FALSE, FALSE, FALSE), ]
```
