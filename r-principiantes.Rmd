---
title: "R para principiantes"
author: "Juan Bosco Mendoza Vega"
site: bookdown::bookdown_site
cover-image: "images/r-principiantes-cover.png"
github-repo: "jboscomendoza/r-principiantes-bookdown"
output:
  bookdown::gitbook:
    highlight: haddock
    lib_dir: assets
    split_by: section
    config:
      toolbar:
        position: static
  bookdown::pdf_book:
    keep_tex: yes
    highlight: haddock
  bookdown::html_book:
    css: toc.css
    highlight: haddock
    documentclass: book
    theme: journal
---

# Prefacio {-}
```{r, echo=FALSE}
knitr::include_graphics("images/r-principiantes-cover.png")
```

Este libro esta dirigído a personas que nunca han usado R o ningún otro lenguaje de programación. No es necesario conocimiento previo de estadística.

El propósito es que lector:

*	conozca las características principales de R
*	se familiarice con los tipos y estructuras de datos usados en R
*	pueda definir sus propias funciones

Este libro está enfocado a aprender el uso de R como un lenguaje de programación.

**Bibliografía básica de referencia**

*	Diez, D., Barr, C., Çetinkaya-Rundel, M. (2015). OpenIntro Statistics, segunda edición. OpenIntro. https://www.openintro.org/stat/textbook.php?stat_book=os 
*	Grolemund y Wickham. (2017). R for Data Science. O’Reilly. http://r4ds.had.co.nz/ 
*	Navarro, D. (2015). Learning statistics with R: A tutorial for psychology students and other beginners. University of Adelaide. http://www.fon.hum.uva.nl/paul/lot2015/Navarro2014.pdf 
*	Peng, R. D. (2016). R Programming for Data Science. Leanpub. https://leanpub.com/rprogramming 
*	RStudio Cheat Sheets. https://www.rstudio.com/resources/cheatsheets/
*	Wickham, H. (2014) Advanced R. O’Reilly.  http://adv-r.had.co.nz/ 
*	Wickham, H. (2014) Tidy Data. Journal of Statistical Software. https://www.jstatsoft.org/article/view/v059i10/v59i10.pdf 


<!--chapter:end:index.Rmd-->

# Introducción: ¿Qué es R y para qué es usado?

R es un lenguaje de programación y entorno computacional dedicado a la estadística. 

Decimos que es un lenguaje de programación porque nos permite dar instrucciones, usando código, a nuestros equipos de cómputo para que realicen tareas específicas (además de que es Turing Completo, pero no nos metamos en eso aún), para ello sólo necesitamos un intérprete para este código y es a esto a lo que llamamos un entorno computacional. 

Cuando instalamos R en nuestra computadora en realidad lo que estamos instalando es el entorno computacional y para que podamos hacer algo en ese entorno necesitamos conocer la manera de escribir instrucciones que pueda interpretar y ejecutar. Eso es lo que aprenderemos a hacer en este curso.

R es diferente a otros lenguajes de programación que están diseñados para realizar muchas tareas diferentes porque fue creado con el único propósito de hacer estadística. Esta característica es la razón de que R sea un lenguaje de programación peculiar, que puede resultar absurdo en algunos sentidos para personas con experiencia en otros lenguajes, pero también es la razón por la que R es una herramienta muy poderosa para el trabajo en estadística, puesto que funciona de la manera que una persona especializada en esta disciplina desearía que lo hiciera.

Para entender mejor estas peculiaridades, nos conviene conocer un poco de los orígenes de este lenguaje de programación.

## Un poco de historia
R tiene sus orígenes en S, un lenguaje de programación creado en los Laboratorios Bell de Estados Unidos. Sí, los mismos laboratorios que inventaron el transistor, el láser el sistema operativo Unix y algunas otras cosas más. 

Dado que S y sus estándares son propiedad de los Laboratorios Bell, lo cual restringe su uso, Ross Ihaka y Robert Gentleman, de la Universidad de Auckland en Nueva Zelanda, decidieron crear una implementación abierta y gratuita de S. Este trabajo, que culminaría en la creación de R inició en 1992, teniendo una versión inicial del lenguaje en 1995 y en el 2000 una versión final estable.

R hereda muchas características de S, por lo que puedes correr código de este lenguaje usando R sin mayor problema. Para lograr esto, en R frecuentemente existe más de una manera de realizar tareas comunes, una compatible con S y otra diseñada específicamente para R. Lo anterior tiene como resultado inconsistencias, sintaxis poco intuitiva y abundante frustración de cabeza para las personas que quieren aprender R. 

En el presente, el mantenimiento y desarrollo de R es realizado por el R Development Core Team, un equipo de especialistas en ciencias computacionales y estadística provenientes de diferentes instituciones y lugares alrededor del mundo. La versión de R mantenida por este equipo es conocida como “base” y como su nombre indica, es sobre aquella que se crean otras implementaciones de R así como los paquetes que expanden su funcionalidad.

Para lograr que R sea usado sin restricciones es distribuido de manera gratuita, a través de la Licencia Pública General de GNU, por lo que es software libre y de código abierto. Si lo deseas, puedes examinar y estudiar el código que hace que R funcione o puedes crear versiones propias de R que se ajusten a tus necesidades particulares. Esta licencia también te permite usar R para los fines que desees, sin limitaciones, no importando si personales, académicos o comerciales.

En la actualidad, el desarrollo de este lenguaje de programación se mantiene activa. La versión más reciente de R al momento de escribir este documento es la 3.4.2 “Short Summer” fue publicada en septiembre del 2017 y todos los días son publicados nuevos paquetes y sus respectivas actualizaciones.

## ¿Quién usa R?
R es un lenguaje relativamente joven pero que ha experimentado un crecimiento acelerado en su adopción durante los últimos 10 años. 

En septiembre de 2017, de acuerdo al TIOBE programming community index (2017), uno de los índices de más prestigio en el mundo sobre popularidad en el uso de leguajes de programación, R era el lenguaje número 11 en popularidad, después de haber sido el lenguaje número 18 en el 2016. Esto es sobresaliente si consideramos que R es un lenguaje dedicado únicamente a la estadística, mientras que lenguajes como Python (número 5 en 2017) o Java (número 1) son lenguajes que pueden ser usados para todo tipo de tareas, desde crear sitios web hasta programar robots.

La adopción de R se debe en gran medida a que permite responder preguntas mediante el uso de datos de forma efectiva, y como es un lenguaje abierto y gratuito, se facilita compartir código, crear herramientas para solucionar problemas comunes y que todo tipo de personas interesadas en análisis estadísticos puedan participar y contribuir al desarrollo y uso de R, no sólo aquellas que tengan acceso a licencias de software cerrado. 

Incluso compañías e instituciones que no tendrían ninguna dificultad para financiar el costo de licencias de software cerrado utilizan R.

R es usado por Facebook para analizar la manera en que sus usuarios interactúan con sus muros de publicaciones para así determinar qué contenido mostrarles. Esta es una tarea muy importante en Facebook, pues las interacciones de los usuarios con publicidad y contenido pagado son la principal fuente de ingreso de esta compañía.  Además de que su división de recursos humanos para estudiar las interacciones entre sus trabajadores. 

Google usa R para analizar la efectividad las campañas de publicidad implementadas en sus servicios, por ejemplo, los anuncios pagados que te aparecen cuando “googleas” algo. Nuevamente, esta es la principal fuente de ingresos de esta compañía. R También es usado para hacer predicciones económicas y otras actividades. 

Microsoft adquirió y ahora desarrolla una versión propia de R llamada OpenR, que ha hecho disponible para uso general del público. OpenR es empleada para realizar todo tipo de análisis estadísticos, por ejemplo, para empatar a jugadores en la plataforma de videojuegos XBOX Live (así que puedes culpar a R cuando te tocan partidas contra jugadores mucho más hábiles que tu). 

Otras compañías que usan R de modo cotidiano son American Express, IBM, Ford, Citibank, HP y Roche, entre  muchas más (Bhalla, 2016; Level, 2017; Microsoft, 2014).

Lo anterior ilustra algunas de las aplicaciones específicas de este lenguaje y de manera general podemos decir que R es usado para procesar, analizar, modelar y comunicar datos. 

Aunque R está diseñado para análisis estadístico, con el paso del tiempo los usuarios de este lenguaje han creado extensiones a R, llamadas paquetes, que han ampliado su funcionalidad. En la actualidad es posible realizar en R minería de textos, procesamiento de imagen, visualizaciones interactivas de datos y  procesamiento de Big Data, entre muchas otras cosas.

Así que, empecemos a usar R.

**Referencias**

* Level (2017). How Big Companies Are Using R for Data Analysis. Recuperado en septiembre de 2017 de: http://www.northeastern.edu/levelblog/2017/05/31/big-companies-using-r-data-analysis/ 
* Microsoft (2014). Companies using R in 2014. Recuperado en septiembre de 2017 de: http://blog.revolutionanalytics.com/2014/05/companies-using-r-in-2014.html 
* Bhalla, D. (2016) Companies using R. Recuperado en septiembre de 2017 de: http://www.listendata.com/2016/12/companies-using-r.html 
* R FAQ. Recuperado en Septiembre de 2017 de: https://cran.r-project.org/doc/FAQ/R-FAQ.html#What-is-R_003f 
* TIOBE Index for September 2017. Recuperado en Septiembre de 2017 de: https://www.tiobe.com/tiobe-index/ 
* Adesanya, T. (2017). A Gentler Introduction to Programming. Recuperado en Septiembre de 2017 de: https://medium.freecodecamp.org/a-gentler-introduction-to-programming-707453a79ee8 

<!--chapter:end:01-intro.Rmd-->

# Instalación
La manera de instalar R cambia dependiendo del sistema operativo utilices pero todas tienen en común el uso de **CRAN**.

[CRAN](https://cran.r-project.org/) es el *The Comprehensive R Archive Network*, una red en la que se archivan todas las versiones de R *base*, así como todos los paquetes para R que han pasado por un proceso de revisión riguroso, realizado por el *CRAN Team*, que se encarga de asegurar su correcto funcionamiento.

CRAN es una red porque existen copias de su contenido en diferentes servidores alrededor del mundo, los cuales se actualizan diariamente. De este modo, no importa de qué servidor de CRAN descargues R o algún paquete, lo que vas a obtener será la versión más reciente de ese recurso, que es igual a la disponible en todos los demás servidores.

Como veremos más adelante, cuando descargamos un paquete de R, lo estamos haciendo desde CRAN, a menos que indiquemos otra cosa.

El sitio oficial de CRAN, en el que encontrarás más información sobre este repositorio es el siguiente:

* https://cran.r-project.org/ 

## Windows
Para instalar R en Windows, la forma más simple es descargar la versión más reciente de R *base* desde el siguiente enlace de CRAN:

* https://cran.r-project.org/bin/windows/base/

El archivo que necesitamos tiene la extensión **.exe** (por ejemplo *R-3.5.1-win.exe*). Una vez descargado, lo ejecutamos como cualquier instalable.

Después de la instalación, estamos listos para usar R.

## OSX
Para instalar R en OSX, se sigue un procedimiento similar que en Windows. Necesitamos descargar los archivos binarios de R base desde CRAN y ejecutarlos.

* https://cran.r-project.org/bin/macosx/ 

Al concluir la instalación, podremos usar R, incluso llamándolo directamente desde la consola.

## Linux
En Linux, como suele ser el caso para casi todo, hay una manera fácil y una difícil de instalar R.

La manera fácil depende de la  presencia de R en los repositorios de la distribución de Linux que estés usando. Si R se encuentra en los repositorios de tu distribución, sólo es necesario usar el gestor de paquetes de tu preferencia para instalarlo, como cualquier otro *software*.

Si R no se encuentra en los repositorios, debes agregar una entrada a tu lista de fuentes de software. Esta entrada depende de tu distribución. 

También tienes la opción de puedes compilar R directamente desde archivos fuente.

Para todas las opciones anteriores, los detalles de instalación se se encuentran en el siguiente enlace:

* https://cran.r-project.org/bin/linux/ 

Si estás usando Linux no te debería ser difícil seguir las instrucciones presentadas.

## RStudio - un IDE para R
Aunque podemos usar R directamente, es recomendable instalar y usar un entorno integrado de desarrollo (*IDE*, por sus siglas en inglés). 

Podemos utilizar R ejecutando nuestro código directamente desde documentos de texto plano, pero esta es una manera poco efectiva de trabajar, especialmente en proyectos complejos.

Un IDE nos proporciona herramientas para escribir y revisar nuestro código, administrar los archivos que estamos usando, gestionar nuestro entorno de trabajo y algunas otras herramientas de productividad. Tareas que serían difíciles o tediosas de realizar de otro modo, son fáciles a través de un IDE.

Hay varias opciones de IDE para R,  y entre ellas mi preferido es [RStudio](https://www.rstudio.com/). Este entorno, además de incorporar las funciones esenciales de una IDE, es desarrollado por un equipo que ha contribuido de manera significativa para lograr que R sea lenguaje de programación más accesible, con un énfasis en la colaboración y la reproducción de los análisis.

Para instalar RStudio, es necesario con descargar y ejecutar alguno de los instaladores disponibles en su sitio oficial. Están disponibles versiones para Windows, OSX y Linux.

* https://www.rstudio.com/products/rstudio/download/ 

Si ya hemos instalado R en nuestro equipo, RStudio lo detectará automáticamente y podremos utilizarlo desde este entorno. Si no instalamos RStudio antes que R, no hay problema, cada vez que iniciamos este programa, verificará la instalación de R.

<!--chapter:end:02-instalacion.Rmd-->

# Conceptos básicos
Para trabajar con R es necesario conocer un poco del vocabulario usado en en este lenguaje de programación. Los siguientes son conceptos básicos que usaremos a lo largo de todo el libro.

## La consola de R
Lo primero que nos encontramos al ejecutar R es una pantalla que nos muestra la versión de este lenguaje que estamos ejecutando y un *prompt*:

`>_                                               ` 

Esta es la consola de R y corresponde al **entorno computacional** de este lenguaje. Es aquí donde nuestro código es interpretado.

Podemos escribir código directamente en la consola y R nos dará el resultado de lo pidamos allí mismo. Esta es la razón pora la que se dice que R permite el uso interactivo, pues no es necesario compilar nuestro código para ver sus resultados.

Si estás usando RStudio, te encontrarás la consola de R en uno de los páneles de este programa.


## Ejecutar, llamar, correr y devolver
Cuando hablamos de ejecutar, llamar o correr nos referimos a pedir que R realice algo, en otras palabras, estamos dando una instrucción o una *entrada*. 

Cuando decimos que R nos devuelve algo, es que ha realizado algo que le hemos pedido, es decir, nos está dando una *salida*.

Por ejemplo, si escribimos los siguiene en la consola lo siguiente y damos Enter, estamos pidiendo que se ejecute esta operación:
`> 1 + 1`

Y nos será devuelto su resultado:
`[1] 2`

## Objetos
En R, todo es un objeto. Todos los datos y estructuras de datos son objetos. Además, todos los objetos tienen un nombre para identificarlos.

La explicación de esto es un tanto compleja y se sale del alcance de este libro. Se relaciona con el paradigma de **programación orientada a objetos** y ese es todo un tema en sí mismo.

Lo importante es que recuerdes que al hablar de un objeto, estamos hablando de cualquier cosa que existe en R y que tiene un nombre.

## Constantes y variables
De manera análoga al uso de estos términos en lenguaje matemático, una constante es un objeto cuyo valor no podemos cambiar, en contraste, una variable es un objeto que puede cambiar de valor.

Por ejemplo, en la siguiente expresión, **$\pi$** y **2** son constantes, mientras que **a** y **r** son variables.

$a = \pi r ^ 2$

Las constantes y variables en R tienen nombres que nos permiten hacer referencia a ellas en operaciones.

Las constantes ya están establecidas por R, mientras que nosotros podemos crear variables, asignandoles valores a nombres.

En R usamos `<-` para hacer asignaciones. De este modo, podemos asignar el valor **3** a la variable **radio**
```{r, echo = TRUE}
radio <- 3
```

Hablaremos sobre asignaciones más adelante, en el capítulo de [operadores](##operadores-de-asignacion).

Es recomendable que al crear una variable usemos **nombres claros, no ambiguos y descriptivos**. Esto previene confusión y hace que nuestro código sea más fácil de comprender por otras personas o por nosotros mismos en el futuro.

Los nombres de las variables pueden incluir letras, números, puntos y guiones bajos. Deben empezar siempre con una letra o un punto y si empiezan con un punto, a este no puede seguirle un número.

Finalmente, cuando te encuentres con un renglón de código que inicia con un gato (hashtag), esto representa un comentario, es código que no se ejecutará, sólo se mostrará.
```{r, echo=TRUE}
# Este es un comentario
```

## Funciones (introducción básica)
Una función es **una serie de operaciones a la que les hemos asignados un nombre**. Las funciones aceptan **argumentos**, es decir, especificaciones sobre cómo deben funcionar.

Cuando llamamos una función, se realizan las operaciones que contiene, usando los argumentos que hemos establecido.

En R reconocemos a una función usando la notación: `nombre_de_la_función()`. Por ejemplo:

* `mean()`
* `quantile()`
* `summary()`
* `density()`
* `c()`

Al igual que con las variables, se recomienda que los nombres de las funciones sean claros, no ambiguos y descriptivos. Idealmente, el nombre de una función  describe lo que hace. De hecho, es probable que adivines qué hacen casi todas funciones de la lista de arriba a partir de su nombre.

Aunque estrictamente hablando una función es un objeto, para fines de explicación, en este libro nos referiremos a ambos como si fueran cosas diferentes.

Las funciones son un tema que revisamos más adelante. Por el momento, recuerda que una función realiza operaciones y nos pide argumentos para poder llevarlas a cabo.

## Directorio de trabajo
El directorio o carpeta de trabajo es el lugar en nuestra computadora en el que se encuentran los archivos con los que estamos trabajando en R. Este es el lugar donde R buscara archivos para importarlos y al que serán exportados, a menos que indiquemos otra cosa.

Puedes encontrar cuál es tu directorio de trabajo con la función `getwd()`. Sólo tienes que escribir la función en la consola y ejecutarla.
```{r, echo = TRUE}
getwd()
```
Se mostrará en la consola la ruta del directorio que está usando R.

Puedes cambiar el directorio de trabajo usando la función `setwd()`, dando como argumento la ruta del directorio que quieres usar.
```{r, echo = TRUE, eval = FALSE}
setwd("C:\otro_directorio")
```

Por último, si deseas conocer el contenido de tu directorio de trabajo, puedes ejecutar. la función `list.files()`, sin argumentos, que devolverá una lista con el nombre de los archivos de tu directorio de trabajo. La función `list.dirs()`, también sin argumentos` te dará una lista de los directorios dentro del directorio de trabajo.

```{r}

```

### Sesión
Los objetos y funciones de R son almacenados en la memoria RAM de nuestra computadora.

Cuando ejecutamos R, ya sea directamente o a través de RStudio, estamos creando una instancia del entorno del entorno computacional de este lenguaje de programación. **cada instancia es una sesión**.

Todos los objetos y funciones creadas en una sesión, permanecen sólo en ella, no son compartidos entre sesiones, sin embargo una sesión puede tener el mismo directorio de trabajo que otra sesión.

Es posible tener más de una sesión de R activa en la misma computadora. Aunque ambas

Cuando cerramos R, también cerramos nuestra sesión. Se nos preguntará si deseamos guardar el contenido de nuestra sesión para poder volver a ella después. Esto se guarda en un archivo con extensión **.Rdata* en tu directorio de trabajo.

Para conocer los objetos y funciones que contiene nuestra sesión, usamos la función `ls()`, que nos devolverá una lista con los nombres de todo lo guardado en la sesión.
```{r, echo = TRUE, EVAL=FALSE}
ls()
```

De manera más precisa, nuestra sesión es un **entorno** de trabajo y los objetos pertenecen a un entorno específico. 

Los entornos son un concepto importante al hablar de lenguajes de programación, pero también son un tema que sale del alcance de este libro. 

Con que recuerdes que **cada sesión de R tiene su propio entorno global**, eso será suficiente.

## Paquetes
R puede ser expandido con **paquetes**. Cada paquete es una colección de funciones diseñadas para atender una tarea específica. Por ejemplo, hay paquetes para trabajo visualización geoespacial, análisis psicométricos, mineria de datos, interacción con servicios de internet y muchas otras cosas más.

Estos paquetes se encuentran alojados en **CRAN**, así que pasan por un control riguroso antes de estar disponibles para su uso generalizado.

Podemos instalar paquetes usando la función `install.packages()`, dando como argumento el nombre del paquete que deseamos instalar, entre comillas.

Por ejemplo, para instalar el paquete **readr**, corremos lo siguiente.
```{r, echo=TRUE, eval=FALSE}
install.packages("readr")
```

Hecho esto, apareceran algunos mensajes en la consola mostrando el avance de la instalación

Una vez concluida la instalación de un paquete, podrás usar sus funciones con la función `library()`. Sólo tienes que llamar esta función usando como argument oel nombre del paquete que quieres utilizar
```{r,echo=TRUE, eval=FALSE}
library(readr)
```

Cuando haces esto, R importa las funciones contenidas en el paquete al entorno de trabajo actual. 

Es importante que tengas en mente que debes hacer una llamada a  `library()` cada que inicies una sesión en R. Aunque hayas importado las funciones de un paquete con anterioridad, las sesiones de R se inician "limpias", sólo con los objetos y funciones de *base*.

Este comportamiento es para evitar problemas de compatibilidad y  para propiciar buenas prácticas de colaboración. 

Si importamos paquetes automáticamente y usamos sus funciones sin indicar de donde provienen, al compartir nuestro código con otras personas, estas no tendrán la información completa para entender qué estamos haciendo. R, al pedirnos que cada sesión indiquemos qué estamos importando, nos obliga a ser explícito con todo lo que estamos haciendo. Es un poco latoso, pero te acostumbras a ello.

En caso de escribir en `install.packages()` el nombre de un paquete no disponible en **CRAN**, se nos mostrará una advertencia y no se instalará nada.
```{r, echo=TRUE, eval=FALSE}
install.packages("un_paquete_falso")
```

Los paquetes que hemos importado en nuestra sesión actual aparecen al llamar `sessionInfo()`.

También podemos ver qué paquetes tenemos ya instalados ejecutando la función `installed.packages()` sin ningún argumento. Una instalación nueva de R tiene pocos paquetes instalados, pero esta lista puede crecer considerablemente con el tiempo.

<!--chapter:end:03-vocabulario.Rmd-->

# Tipos de datos
En R los datos pueden ser de diferentes tipos. Los siguientes son los comunes.

Tipo            | Ejemplo | Nombre en inglés
-----           | -----   |----
Entero          | 1       | integer
Numérico        | 1.3     | numeric
Complejo        | 1+0i    | complex 
Cadena de texto | "uno"   | character
Factor          | uno     | factor
Lógico          | TRUE    | logical
Perdido         | NA      | NA
Vacio           | NULL    | null

Cada tipo de dato tiene características particulares que lo hace diferente a los demás.

Los datos numéricos también son llamados **dobles** o **floats (flotantes)**. Su nombre se deb a que son números de doble precisión, pues tienen una parte entera y una fraccionaria decimal, y son llamados floats debido a que se usa un punto flotante para su representación computacional. Para fines prácticos todos estos términos son sinónimos y son usados de manera mas o menos intercambiable en libros y documentación, lo mismo ocurrirá en este libro.

Los datos de tipo lógico sólo tienen dos valores posibles: **TRUE** (verdadero) y **FALSE** (falso). Este tipo de datos es esencial para trabajar con álgebra booleana.

**NA** se usa para representar datos perdidos y en R es diferente a **NULL**. **NULL** representa la ausencia de datos, es decir, que no hay nada que recuperar, mientras que **NA** representa un valor específico, de un dato que se reporta como perdido o ausente.

El tipo *character* representa cadenas de texto y es fácil reconocerlo porque un dato siempre esta rodeado de comillas, simples o dobles.

Las cadenas de texto son diferentes a los factores aunque suelen lucir igual en la consola. Un factor puede ser descrito como un dato numérico representado por una etiqueta. Cada uno de las etiquetas o valores que puedes asumir un factor se conoce como **nivel**.

Por ejemplo, podemos tener un conjunto de datos de tipo factor con dos niveles, **femenino (1)** y **masculino (2)**. Para nuestra computadora, femenino tiene un valor de 1, pero a nosotros se nos muestra la palabra *femenino*. Por su parte, las cadenas de texto no son representaciones de datos numéricos, son 

Por esta razón, si intentamos coercionar un factor a tipo numérico, tendremos éxito, pero si intentamos lo mismo con una cadena de texto, se nos mostrara una advertencia y el resultado será **NA**.

Podemos usar la función **class()** para determinar el tipo de un dato.
```{r, echo=TRUE}
class(3)
class("3")
class(TRUE)
```

## Coerción
En R, los datos pueden ser coercionados (forzados) para convertirlos de un tipo a otro. Cuando pedimos a R que ejecute una operación, R intentará coercionar los datos al tipo correcto que permita realizarla. Si no lo logra, nos devuelve como resultado un error.

La coerción de tipos se realiza de los más restrictivos a los más flexibles.

Como los datos de tipo lógico sólo admiten dos valores (`TRUE` y `FALSE`), estos son los más restrictivos; mientras que los datos de cadena de texto, al admitir cualquier cantidad y combinación de caracteres, son los más flexibles.

Por ejemplo, podemos coercionar un dato de tipo entero a tipo numérico, pero no un dato de tipo cadena de texto a numérico.

Las coerciones siguen este orden:

`logical -> integer -> numeric -> complex -> character`

Podemos pedir a R que haga coerción usando la familia de funciones `as()`.

Función         | Tipo al que hace coerción
-----           | -----
as.integer()    | Entero
as.numeric()    | Numerico
as.complex()    | Complejo
as.character()  | Cadena de texto
as.factor()     | Factor
as.logical()    | Lógico
as.null()       | NULL

Por ejemplo, con `as.character()`, podemos convertir un número en una cadena de texto.
```{r, echo=TRUE}
as.character(5)
```

Estas funciones siguen las reglas de coerción de R, así que no podemos hacer forzar coerciones no permitidas.
```{r, echo=TRUE, error=TRUE}
as.logical("palabra")
```

## Verificar el tipo de un dato
También podemos verificar si un dato es de un tipo específico con la familia de funciones `is()`. 

Función         | Tipo que verifican
-----           | -----
is.integer()    | Entero
is.numeric()    | Numerico
is.complex()    | Complejo
is.character()  | Cadena de texto
is.factor()     | Factor
is.logical()    | Lógico
is.null()       | NULL

Si el dato es del tipo que estamos verificando, estas funciones nos devolverán `TRUE` y en caso contrario devolverán `FALSE`.
```{r, echo=TRUE}
is.numeric(5)

is.character(5)
```

<!--chapter:end:04-datos.Rmd-->

# Operadores
Los operadores son los símbolos que le indican a R que debe realizar una tarea. Combinando datos y operadores es que logramos que R haga su trabajo.

Existen operadores específicos para cada tipo de tarea. Los tipos de operadores principales son los siguientes:

* Aritméticos
* Relacionales
* Lógicos
* De asignación

Familiarizarnos con los operadores nos permitirá manipular y transformar datos de distintos tipos. 

## Operadores aritméticos
Como su nombre lo indica, este tipo de operador es usado para operaciones aritméticas.

En R tenemos los siguientes operadores aritméticos:

Operador| Operación       | Ejemplo | Resultado
----    |----             |----     |----
+       | Suma            | 5 + 3   | 8
-       | Resta           | 5 - 3   | 2
*       | Multiplicación  | 5 * 3   | 18
/       | División        | 5 /3    | 1.666667
^       | Potencia        | 5 ^ 3   | 125
%%      | División entera | 5 %% 3  | 2

Es posible realizar operaciones aritméticas con datos de tipo **entero** y **numérico**. 

Si escribes una operación aritmética en la consola de R y das Enter, esta se realiza y se devuelve su resultado.
```{r, echo=TRUE}
15 * 3
```

Cuando intentas realizar una operación aritmética con otro tipo de dato, R primero intentará coercionar ese dato a uno numérico. Si la coerción tiene éxito se realizará la operación normalmente, si falla, el resultado será un error.

Por ejemplo, `4 + "tres"` devuelve: `Error in 4 + "tres" : non-numeric argument for binary operator."`
```{r, echo=TRUE, error=TRUE}
4 + "tres"
```
  
El mensaje *"non-numeric argument for binary operator"* aparece siempre que intentas realizar una operación aritmética con un argumento no numérico. Si te encuentras un un error que contiene este mensaje, es la primera pista para que identifiques donde ha ocurrido un problema.

Cualquier operación aritmética que intentemos con un dato `NA`, devolverá `NA` como resultado.
```{r, echo = TRUE}
NA - 66

21 * NA

NA ^ 13
```

### La división entera
Entre los operadores aritméticos, el de división entera o **modulo** requiere una explicación adicional sobre su uso. La operación que realiza es una división de un número entre otro, pero en lugar de devolver el cociente, nos devuelve el residuo.

Por ejemplo, si hacermos una división entera de 4 entre 2, el resultado será 0. Esta es una división exacta y no tiene residuo.
```{r, echo =TRUE}
4 %% 2
```

En cambio, si hacemos una división entera de 5 entre 2, el resultado será 1, pues este es el residuo de la operación.
```{r, echo =TRUE}
5 %% 2
```

## Operadores relacionales
Los operadores lógicos son usados para hacer comparaciones y siempre devuelven como resultado `TRUE` o `FALSE` (verdadero o falso, respectivamente).

Operador| Comparación           | Ejemplo | Resultado
----    |----                   |----     |----
<       | Menor que             | 5 < 3   | FALSE
<= 	    | Menor o igual que     | 5 <= 3  | FALSE
>       |	Mayor que             | 5 > 3   | TRUE
>= 	    | Mayor o igual que     | 5 >= 3  | TRUE
== 	    | Exactamente igual que | 5 == 3  | FALSE
!= 	    | No es igual que       | 5 != 3  | TRUE

Es posible comparar cualquier tipo de dato sin que resulte en un error.

Sin embargo, al usar los operadores `>`, `>=`, `<` y `<=` con cadenas de texto, estos tienen un comportamiento especial. 

Por ejemplo, `"casa" > "barco"` nos devuelve `TRUE`.
```{r}
"casa" > "barco"
```

Este resultado se debe a que se ha hecho una comparación por orden alfabético. En este caso, la palabra "casa" tendría yba posición posterior a "barco", pues empieza con "c" y está letra tiene una posición posterior a la "b" en el alfabeto. Por lo tanto, es verdadero que sea "mayor".

Cuando intentamos comparar factores, siempre obtendremos como resultado `NA` y una advertencia acerca de que estos operadores no son significativos para datos de tipo factor.
```{r, echo=TRUE}
as.factor("casa") > "barco"
```

## Operadores lógicos
Los operadores lógicos son usados para operaciones de **álgebra Booleana**, es decir, para describir relaciones lógicas, expresadas como verdadero (`TRUE`) o falso (`FALSO`).
  
Operador  | Comparación                   | Ejemplo       | Resultado
----      |----                           |----           |----
x | y     |	x Ó y es verdadero            | TRUE | FALSE  | TRUE
x & y     |	x Y y son verdaderos          | TRUE & FALSE  | FALSE
!x        |	x no es verdadero (negación)  | !TRUE         | FALSE
isTRUE(x) |	x es verdadero (afirmación)   | isTRUE(TRUE)  | TRUE

Los operadores `|` y `&` siguen estas reglas:

* `|` devuelve `TRUE` si alguno de los datos es `TRUE`
* `&` solo devuelve `TRUE` si ambos datos es `TRUE`
* `|` solo devuelve `FALSE` si ambos datos son `FALSE`
* `&` devuelve `FALSE` si alguno de los datos es `FALSE`

Estos operadores pueden ser usados con estos con datos de tipo **numérico**, **lógico** y **complejo**. Al igual que con los operadores relacionales, los operadores lógicos siempre devuelven `TRUE` o `FALSE`.

Para realizar operaciones lógicas, todos los valores numéricos y complejos distintos a `0` son coercionados a `TRUE`, mientras que `0` siempre es coercionado a `FALSE`. 

Por ejemplo, `5 | 0` resulta en `TRUE` y `5 & FALSE` resulta en `FALSE`. Podemos comprobar lo anterior con la función `isTRUE()`.
```{r, echo=TRUE}
5 | 0

5 & 0

isTRUE(0)

isTRUE(5)
```

Estos operadores se pueden combinar para expresar relaciones complejas.

Por ejemplo, la negación `FALSE` Y `FALSE` dará como resultado `TRUE`.
```{r, }
!(FALSE | FALSE)
```

También podeos combinar operadores lógicos y relacionales, dado que esto últimos dan como resultado `TRUE` y `FALSE`.
```{r, echo=FALSE}
(4 < 6) | (6 == 6)
```

## Operadores de asignación
Este es probablemente el operador más importante de todos, pues nos permite asignar datos a variables.

Operador  | Operación   
----      |----         
<-        | Asigna un valor a una variable
=         | Asigna un valor a una variable

Aunque podemos usar el signo igual para una asignación, a lo largo de este libro utlizaremos `<-`, por ser característico de R y fácil de reconocer visualmente.

Después de realizar la operación de asignación, podemos usar el nombre de la variable para realizar operaciones con ella, como si fuera del tipo de datos que le hemos asignado. Si asignamos un valor a una variable a la que ya habíamos asignado datos, nuestra variable conserva el valor más reciente.

Además, esta operación nos permite "guardar" el resultado de operaciones, de modo que podemos recuperarlos sin necesidad de realizar las operaciones otra vez. Basta con llamar el nombre de la variable en la consola

En este ejemplo, asignamos valores a las variables `estatura` y `peso`.
```{r, echo=TRUE}
estatura <- 1.73
peso <- 83
```
Llamamos a sus valores asignados
```{r, echo=TRUE}
estatura
peso
```

Usamos los valores asignados para realizar operacions.
```{r, echo=TRUE}
peso / estatura ^ 2
```

Cambiamos el valor de una variable a uno nuevo y realizamos operaciones
```{r, echo=TRUE}
peso <- 76

peso

peso / estatura ^ 2

estatura <- 1.56
peso <- 48

peso / estatura ^ 2
```

Asignamos el resultado de una operación a una variable nueva.
```{r, echo = TRUE}
bmi <- peso / estatura ^ 2

bmi
```

Como podrás ver, es posible asignar a una variable valores de otra variable o el resultado de operaciones con otras variables.
```{r, echo=TRUE}
velocidad_inicial <- 110
velocidad_final <- 185

tiempo_inicial <- 0
tiempo_final <- 15

variacion_velocidad <- velocidad_final - velocidad_inicial
variacion_tiempo <- tiempo_final - tiempo_inicial

variacion_velocidad / variacion_tiempo
```

<!--chapter:end:05-operadores.Rmd-->

# Estructuras de datos
Las estructuras de datos son objetos que contienen datos. Cuando trabajamos con R, lo que estamos haciendo es manipular estas estructuras.

Las estructuras tienen diferentes características. Entre ellas, las que distinguen a una estructura de otra son su número de **dimensiones** y si son **homogeneas** o **hereterogeneas**.

La siguiente tabla muestra las principales estructuras de control que te encontrarás en R.

Dimensiones| Homogeneas| Heterogeneas
----       |----       |----
1          | Vector    | Lista
2          | Matriz    | Data frame 
n          | Array     | 
*Adaptado de Wickham (2016).*

Veamos las características de cada una de ellas.

## Vectores
Un vector es la estructura de datos más sencilla en R. Un vector es una colección de uno o más datos del mismo tipo.

Todos los vectores tienen tres propiedades:

* **Tipo**. Un vector tiene el mismo tipo que los datos que contiene. Si tenemos un vector que contiene datos de tipo numérico, el vector será también de tipo numérico. Los vectores son **atómicos**, pues sólo pueden contener datos de un sólo tipo, no es posible mezclar datos de tipos diferentes dentro de ellos.
* **Largo**. Es el número de elementos que contiene un vector. El largo es la única **dimensión** que tiene esta estructura de datos.
* **Atributos**. Los vectores pueden tener metadatos de muchos tipos, los cuales describen características de los datos que contienen. Todos ellos son incluidos en esta propiedad. Nosotros no usaremos vectores con metadatos, por ser una propiedad con usos muy específicos que van más allá del alcance de este libro.

Cuando una estructura unicamente puede contener datos de un sólo tipo, como es el caso de los vectores, decimos que es **homogénea**, pero no implica que necesariamente sea **atómica**. Regresaremos sobre esto al hablar de matrices y arrays.

Como los vectores son la estrucutra de datos más sencilla de R, datos simples como el número **3**, son en realidad vectores. En este caso, un vector de tipo númerico y largo igual a 1.
```{r, echo=TRUE}
3
```

Verificamos que  el **3** es un vector con la función `is.vector()`.
```{r, echo=TRUE}
is.vector(3)
```

Y usamos la función `length()` para conocer su largo.
```{r, echo=TRUE}
length(3)
```

Lo mismo ocurre con los demás tipos de datos, por ejemplo, con cadenas de texto y datos lógicos.
```{r, echo=TRUE}
is.vector("tres")
is.vector(TRUE)
```

### Creación de vectores
Creamos vectores usando la función `c()` (*combinar*). 

Llamamos esta función y le damos como argumento los elementos que deseamos combinar en un vector, separados por comas.
```{r, echo=TRUE}
# Vector numérico
c(1, 2, 3, 5, 8, 13)

# Vector de cadena de texto
c("arbol", "casa", "persona")

# Vector lógico
c(TRUE, TRUE, FALSE, FALSE, TRUE)
```

Si deseamos agregar un elemento a un vector ya existente, podemos hacerlo combinando nuestro vector original con los elementos nuevos y asignando el resultado a nuestro vector original.
```{r, echo=TRUE}
mi_vector <- c(TRUE, FALSE, TRUE)

mi_vector <- c(mi_vector, FALSE)

mi_vector
```

Naturalmente, podemos crear vectores que son combinación de vectores.
```{r, echo=TRUE}
mi_vector_1 <- c(1, 3, 5)
mi_vector_2 <- c(2, 4, 6)

mi_vector_3 <- c(mi_vector_1, mi_vector_2)

mi_vector_3
```

Si intentamos combinar datos de diferentes tipos en un mismo vector, R realizará coerción automáticamente. El vector resultante será del tipo más flexible entre los datos que contenga, siguiendo las reglas de ***coerción***.

Creamos un vector numérico.
```{r, echo=TRUE}
mi_vector <- c(1, 2, 3)

class(mi_vector)
```

Si intentamos agregar un dato de tipo cadena de texto, nuestro vector ahora sera de tipo cadena de texto.
```{r}
mi_vector_nuevo <- c(mi_vector, "a")

class(mi_vector_nuevo)
```

Como las cadenas de texto son el tipo de dato más flexible, siempre que creamos un vector que incluye un dato de este tipo, el resultado será un vector de texto.
```{r}
mi_vector_mezcla <- c(FALSE, 2, "tercero", 4.00)

class(mi_vector_mezcla)
```

### Vectorización de operaciones
Existen algunas operaciones al aplicarlas a un vector, se aplican a cada uno de sus elementos. A este proceso le llamamos **vectorización**.

Por ejemplo, las operaciones aritméticas pueden vectorizarse. Si las aplicamos a un vector, la operación se realizará para cada uno de los elementos que contiene.
```{r, echo=TRUE}
# Nuestro vector
mi_vector <- c(2, 3, 6, 7, 8, 10, 11)

# Las operaciones
mi_vector + 2
mi_vector * 2
mi_vector / 2
mi_vector ^ 2
mi_vector %% 2
```

Esta manera de aplicar una operación es muy eficiente. Comparada con otros procedimientos, requiere de menos tiempo de cómputo, lo cual a veces es considerable, en particular cuando trabajamos con un número grande de datos.

Aunque el nombre de este proceso es **vectorización**, también funciona, en ciertas circunstancias, para otras estructuras de datos.

## Matrices y arrays
Las matrices y arrays pueden ser descritas como **vectores multidimensionales**. Al igual que un vector, únicamente pueden contener datos de un sólo tipo, pero además de largo, tienen más dimensiones.

En un sentido estricto, las matrices son una caso especial de un array, que se distingue por tener **específicamente dos dimensiones**, un "largo"" y un "alto". Las matrices son, por lo tanto, una estructura con forma rectangular, con renglones y columnas.

Como las matrices son usadas de manera regular en matemáticas y estadística, es una estructura de datos de uso común en R común y en la que nos enfocaremos en este libro.

Los arrays, por su parte, pueden tener un número arbitrario de dimensiones. Pueden ser cubos, hipercubos y otras formas. Su uso no es muy común en R, aunque a veces es deseable contar con objetos n-dimensionales para manipular datos. Como los arrays tienen la restricción de que todos sus datosdeben ser del mismo tipo, no importando en cuantas dimensiones se encuentren, esto limita sus usos prácticos. 

En general, es preferible usar listas en lugar de arrays, una estructura de datos que además tienen ciertas ventajas que veremos más adelante.

### Creación de matrices
Creamos matrices en R con la función `matrix()`. La función `matrix()` acepta dos argumentos, `nrow` y `ncol`. Con ellos especificamos el número de renglones y columnas que tendrá nuestra matriz.
```{r, echo=TRUE}
# Un vector numérico del uno al doce
1:12

# matrix() sin especificar renglones ni columnas
matrix(1:12)

# Tres renglones y cuatro columnas
matrix(1:12, nrow = 3, ncol = 4)

# Cuatro columnas y tres columnas
matrix(1:12, nrow = 4, ncol = 3)

# Dos renglones y seis columnas
matrix(1:12, nrow = 4, ncol = 3)
```

Los datos que intentemos agrupar en una matriz serán acomodados en orden, de arriba a abajo, y de izquierda a derecha, hasta formar un rectángulo.

Si multiplicamos el número de renglones por el número de columnas, obtendremos el número de celdas de la matriz. En los ejemplo anteriores, el número de celdas es igual al número de elementos que queremos acomodar, así que la operación ocurre sin problemas.

Cuando intentamos acomodar un número diferente de elementos y celdas, ocurren dos cosas diferentes. 

Si el número de elementos es mayor al número de celdas, se acomodaran todos los datos que sean posibles y los demás se omitirán. 
```{r, echo=TRUE}
matrix(1:12, nrow = 3, ncol = 3)
```

Si, por el contrario, el número de celdas es mayor que el número de elementos, estos se **reciclaran**. En cuanto los elementos sean insuficientes para acomodarse en las celdas, R nos devolverá una advertencia y se empezaran a usar los elementos a partir del primero de ellos
```{r, echo=TRUE}
matrix(1:12, nrow = 5, ncol = 4)
```

Otro procedimiento para crear matrices es la unión vectores con las siguientes funciones:

* `cbind()` para unir vectores, usando cada uno como una columna.
* `rbind()` para unir vectores, usando cada uno como un renglón.

De este modo podemos crear cuatro vectores y unirlos para formar una matriz. Cada vector será un renglon en esta matriz.

Creamos cuatro vectores, cada uno de largo igual a cuatro.
```{r, echo = TRUE}
vector_1 <- 1:4
vector_2 <- 5:8
vector_3 <- 9:12
vector_4 <- 13:16
```

Usamos `rbind()` para crear un matriz, en la que cada vector será un renglón.
```{r, echo = TRUE}
matriz <- rbind(vector_1, vector_2, vector_3, vector_4)

# Resultado
matriz
```

Si utilizamos `cbind()`, entonces cada vector será una columna.
```{r, echo = TRUE}
matriz <- cbind(vector_1, vector_2, vector_3, vector_4)

# Resultado
matriz
```

Al igual que con `matrix()`, los elementos de los vectores son reciclados para formar una estructura rectangular y se nos muestra un mensaje de advertencia.
```{r, echo = TRUE}
# Elementos de largo diferente
vector_1 <- 1:2
vector_2 <- 1:3
vector_3 <- 1:5

matriz <- cbind(vector_1, vector_2, vector_3)

# Resultado
matriz
```

Finalmente, las matrices pueden contener `NA`s.

Creamos dos vectores con un `NA` en ellos.
```{r, echo=TRUE}
vector_1 <- c(NA, 1, 2)
vector_2 <- c(3,  4, NA)
```

Creamos una matriz con `rbind()`.
```{r}
matriz <- rbind(vector_1, vector_2)

# Resultados
matriz
```

Como `NA` representa datos perdidos, puede estar presente en compañía de todo tipo de de datos.

### Propiedades de las matrices
No obstante que las matrices y arrays son estructuras que sólo pueden contener un tipo de datos, no son atómicas. Su clase es igual a **matriz (matrix)** o **array** segun corresponda.

Verificamos esto usando la función `class()`.
```{r, echo=TRUE}
mi_matriz <- matrix(1:10)

class(mi_matriz)
```

Las matrices y arrays pueden tener más de una dimensión.

Obtenemos el número de dimensiones de una matriz o array con la función `dim()`. Esta función nos devolverá varios números, cada uno de ellos indica la cantidad de elementos que tiene una dimensión.
```{r, echo=TRUE}
mi_matriz <- matrix(1:12, nrow = 4, ncol = 3)
dim(mi_matriz)
```

Cabe señalar que si usamos `dim()` con un vector, obtenemos `NULL`. Esto ocurre con todos los objetos unidimensionales 
```{r, echo=TRUE}
mi_vector <- 1:12

dim(mi_vector)
```

Finalmente, las operaciones aritméticas también son vectorizadas al aplicarlas a una matriz. La operación es aplicada a cada uno de los elementos de la matriz.

Creamos una matriz.
```{r, echo=TRUE}
mi_matriz <- matrix(1:9, nrow = 3, ncol = 3)

# Resultado
mi_matriz
``` 

Intenemos sumar, multiplicar y elevar a la tercera potencia.
```{r}
# Suma
mi_matriz + 1

# Multiplicación
mi_matriz * 2

# Potenciación
mi_matriz ^ 3
```

Si intentamos vectorizar una operación utilizando una matriz con `NA`s, esta se aplicará para los elementos válidos, devolviendo `NA` cuando corresponda.

Creamos una matriz con `NA`s.
```{r, echo=TRUE}
vector_1 <- c(NA, 2, 3)
vector_2 <- c(4, 5, NA)

matriz <- rbind(vector_1, vector_2)

# Resultado
matriz
```

Intentamos dividir sus elementos entre dos.
```{r, echo=T}
matriz / 2
```

Finalmente, podemos usar la función `t()` para transponer una matriz, es decir, rotarla 90°.

Creamos una matriz con tres renglones y dos columnas.
```{r, echo=TRUE}
matriz <- matrix(1:6, nrow = 3)

# Resultado
matriz
```

Usamos `t()` para transponer.
```{r, echo=TRUE}
matriz_t <- t(matriz)

# Resultado
matriz_t
```

Obtenemos una matriz con dos renglones y dos columnas.

## Data frames
Los data frames son estructuras de datos de dos dimensiones (rectangulares) que pueden contener datos de diferentes tipos, por lo tanto, son heterogéneas. Esta estructura de datos es la más usada para realizar análisis de datos y seguro te resultará familiar si has trabajado con otros paquetes estadísticos.

Podemos entender a los data frames como una versión más flexible de una matriz. Mientras que en una matriz todas las celdas deben contener datos del mismo tipo, los renglones de un data frame admiten datos de distintos tipos, pero sus columnas conservan la restricción de contener datos de un sólo tipo.

En términos generales, los renglones en un data frame representan casos, individuos u observaciones, mientras que las columnas representan atributos, rasgos o variables. 
Por ejemplo, así lucen los primeros cinco renglones del objeto **iris**, el famoso conjunto de datos  *Iris de Ronald Fisher*, que está incluido en todas las instalaciones de R.
```{r, echo=FALSE}
head(iris, 5)
```

Los primeros cinco renglones corresponden a cinco casos, en este caso flores. Las columnas son variables con los rasgos de cada flor: largo y ancho de sépalo, largo y ancho de pétalo, y especie.

Para crear un data frame usamos la función `data.frame()`. Esta función nos pedirá un número de vectores igual al número de columnas que deseemos. Todos los vectores que proporcionemos deben tener el mismo largo. 

Esto es muy importante: **Un data frame está compuesto por vectores**.

Más adelante se hará evidente porque esta característica de un data frame es sumamente importante y también, como podemos sacarle provecho.

Además, podemos asignar un nombre a cada vector, que se convertirá en el nombre de la columna. Como todos los nombres, es recomendable que este sea claro, no ambiguo y descriptivo.
```{r, echo = TRUE}
mi_df <- data.frame(
  "entero" = 1:4, 
  "factor" = c("a", "b", "c", "d"), 
  "numero" = c(1.2, 3.4, 4.5, 5.6),
  "cadena" = as.character(c("a", "b", "c", "d"))
)

mi_df

# Podemos usar dim() en un data frame
dim(mi_df)

# El largo de un data frame es igual a su número de columnas
length(mi_df)

# names() nos permite ver los nombres de las columnas
names(mi_df)

# La clase de un data frame es data.frame
class(data.frame) 
```

Si los vectores que usamos para construir el data frame no son del mismo largo, los datos **no se reciclaran**. Se nos devolverá un error.
```{r, echo=TRUE, error=TRUE}
data.frame(
  "entero" = 1:3, 
  "factor" = c("a", "b", "c", "d"), 
  "numero" = c(1.2, 3.4, 4.5, 5.6),
  "cadena" = as.character(c("a", "b", "c", "d"))
)
```

También podemos coercionar esta matriz a un data frame.

Creamos una matriz.
```{r}
matriz <- matrix(1:12, ncol = 4)
```

Usamos `as.data.frame()` para coercionar una matriz a un data frame.
```{r}
df <- as.data.frame(matriz)
```

Verificamos el resultado
```{r}
class(df)

# Resultado
df
```

### Propiedades de un data frame
Al igual que con una matriz, si aplicamos una operación aritmética a un data frame, esta se vectorizará. 

Los resultados que obtendremos dependerán del tipo de datos de cada columna. R nos devolverá todas las advertencias que ocurran como resultado de las operaciones realizadas, por ejemplo, aquellas que hayan requerido una coerción.
```{r, echo=TRUE}
mi_df <- data.frame(
  "entero" = 1:4, 
  "factor" = c("a", "b", "c", "d"), 
  "numero" = c(1.2, 3.4, 4.5, 5.6),
  "cadena" = as.character(c("a", "b", "c", "d"))
)

mi_df * 2
```

## Listas
Las listas, al igual que los vectores, son estructuras de datos unidimensionales, sólo tienen largo, pero a diferencia de los vectores cada uno de sus elementos puede ser de diferente tipo o incluso de diferente clase, por lo que son estructuras heterogéneas.

Podemos tener listas que contengan datos atómicos, vectores, matrices, arrays, data frames u otras listas. Esta última característica es la razón por la que una lista puede ser considerada un vector recursivo, pues es un objeto que puede contener objetos de su misma clase.

Para crear una lista usamos la función `list()`, que nos pedirá los elementos que deseamos incluir en nuestra lista. Para esta estructura, no importan las dimensiones o largo de los elementos que queramos incluir en ella. 

Al igual que con un data frame, tenemos la opción de poner nombre a cada elemento de una lista.

Por último, no es posible vectorizar operaciones aritméticas usando una lista, se nos devuelve un error como resultado.
```{r, echo = TRUE, error=TRUE}
mi_vector <- 1:10
mi_matriz <- matrix(1:4, nrow = 2)
mi_df     <- data.frame("num" = 1:3, "let" = c("a", "b", "c"))

mi_lista <- list("un_vector" = mi_vector, "una_matriz" = mi_matriz, "un_df" = mi_df)

mi_lista
```

Creamos una lista que contiene otras listas.
```{r, echo=TRUE}
lista_recursiva <- list("lista1" = mi_lista, "lista2" = mi_lista)

# Resultado
lista_recursiva
```

### Propiedades de una lista
Una lista es unidimensional, sólo tiene largo.

El largo de una lista es igual al número de elementos que contiene, sin importar de qué tipo o clase sean. Usamos la lista recursiva que creamos en la sección anterior para ilustrar esto.
```{r, echo=TRUE}
length(lista_recursiva)
```

Dado que una lista siempre tiene una sóla dimensión, la función `dim()` nos devuelve `NULL`.
```{r, echo=TRUE}
dim(lista_recursiva)
```

Las listas tienen clase **list**, sin importar qué elementos contengan.
```{r, echo=TRUE}
class(lista_recursiva)
```

Finalmente, no es posible vectorizar operaciones aritméticas usando listas. Al intentarlo nos es devuelto un error.
```{r, echo=TRUE, error=TRUE}
mi_lista / 2
```

Si deseamos aplicar una función a cada elemento de una lista, usamos `lapply()`, como veremos en el [capítulo 10](#apply).

<!--chapter:end:06-estructuras-datos.Rmd-->

# Subconjuntos
En R, podemos obtener subconjuntos de todas las estructuras de datos. Esto es, podemos extraer datos de las estructuras que tengan una o más características en especial.

Para esta extracción usaremos índices, operadores lógicos y álgebra Booleana. Aunque cada estructura de datos de R es diferente, existen procedimientos para obtener subconjuntos que pueden usarse con todas ellas. Por supuesto, hay otras que funcionan sólo con algunas estructuras.

## Índices
Crer subconjuntos usando índices es el procedimiento más universal en R, pues funciona con todas las estructuras de datos.

Los índices en R son **posicionales**. Cuando usamos este método le pedimos a R que extraiga de una estructura los datos que se encuentran en una o varias posiciones específicas.

Escribimos corchetes `[]` después de un objeto para obtener subconjuntos con índices. Dentro de los corchetes escribimos el o los números que corresponden a la posición que nos interesa extraer del objeto. Por ejemplo:

* `objeto[3]`
* `lista[4:5]` 
* `dataframe[c(2, 7), ]`

Veamos un ejemplo con un vector. Creamos un vector que contiene los nombres de distintos niveles educativos. 
```{r, echo=TRUE}
nivel <- c("Preescolar", "Primaria", "Secundaria", "Educación Media Superior",
           "Educación Superior")

nivel
```
Este es un vector de largo igual a 5.
```{r}
length(nivel)
```

¿Cómo obtendríamos el tercer elemento de este vector usando indices? ¿Y del primer al cuarto elemento? ¿O el segundo y quinto elemento?

Sabemos que los índices son posicionales y que se usan corchetes para realizar la operación de extración, por lo tanto,  las respuestas a las preguntas anteriores son relativamente intuitivas.

Para extraer el tercer elemento hacemos lo siguiente.
```{r, echo=TRUE, error=TRUE}
nivel[3]
```

A diferencia de la mayoría de los lenguajes de programación, los índices en R empiezan en 1, no en 0. El índice del primer elemento de una estructura de datos siempre es 1.

Por lo tanto, para extrar del primer al cuarto elemento de un vector, usamos los números del 1 al 4.
```{r, echo=TRUE}
nivel[1:4]
```

Cuando deseamos extraer elementos en posiciones no consecutivas, usamos vectores. Por ejemplo, para extraer el segundo y quinto elemento del vector ***nivel**, lo siguiente no funciona.
```{r, echo = TRUE, error = TRUE}
nivel[2, 5]
```

Si usamos un vector, tendremos éxito en extraer el segundo y quinto elemento de **nivel**.
```{r, echo=TRUE}
nivel[c(2, 5)]
```

¿Porqué no funcionó usar **nivel[2, 5]** para extraer dos elementos no consecutivos en nuestro vector? 

El mensaje de error nos da una pista muy importante. Al usar una coma dentro de los corchetes estamos pidiendo a R que busque los índices solicitados en más de una dimensión. 

Entonces, al llamar `nivel[2, 5]` le pedimos a R que extraiga el elemento que se encuentA en la posición 2 de la primera dimensión del vector, y el elemento en la posición 5 de su segunda dimensión. Como los vectores son unidimensionales, es imposible cumplir esta instrucción y se produce un error.

En cambio, usar `nivel[c(2, 5)]` funciona porque estamos dando un vector con dos números, pero ambos en una misma dimensión de nuestro objeto.

Para estructuras con más de una dimensión, los índices hacen referencia a posiciones para cada una de ellas. En estructuras de dos dimensiones (matrices y data frames), **el primer índice es para los renglones y la segunda para las columnas**. 

Este es un tipo de operación muy común al trabajar con data frames y matrices

## Índices, data frames y matrices
Para ilustrar cómo usar índices con objetos rectangulares, vamos a crear un data frame llamado **mi_df**. 
```{r, echo=TRUE}
mi_df <- data.frame("nombre" = c("Armando", "Elsa", "Ignacio", "Olga"),
                    "edad" = c(20, 24, 22, 30),
                    "sexo" = c("H", "M", "M", "H"),
                    "grupo" = c(0, 1, 1, 0))

mi_df
```

Confirmamos que nuestro data frame tiene dos dimensiones: tres renglones y tres columnas.
```{r, echo=TRUE}
dim(mi_df)
```


Con índices podemos extraer un dato que se encuentra en un renglón y columna específico.
```{r, echo=TRUE}
# Extraer dato en el tercer renglón y tercera columna
mi_df[3, 3]

# Extraer dato en el primer renglón y segunda columna
mi_df[1, 2]

# Extraer dato en el segundo renglón y el primer renglón
mi_df[2, 1]
```


```{r, echo=TRUE}
# Extraer dato en 
mi_df[1:2, 3:4]

# Si dejamos vacio el índice para una dimensión, nos son devueltos todos 
# los datos que contiene
mi_df[ , 1]
mi_df[1,  ]

# Podemos usar vectores para elegir elementos no consecutivos
mi_df[c(1, 3),  c(1, 4)]
```



Para objetos de tres o más dimensiones se siguen las mismas reglas, aunque ya no es tan fácil hablar de renglones y columnas. Por ejemplo, un array de cuatro dimensiones.

```{r, echo=TRUE}
mi_array <- array(data = 1:16, dim = c(2, 2, 2, 2))

# Comprobamos las dimensiones
dim(mi_array)

# Así luce un array sencillo de cuatro dimensiones.
mi_array

# Un par de subconjuntos
mi_array[1, 2, 1, 2]
mi_array[ , 1, 1, 1]

```

Finalmente, conviene saber que la posición de los elementos en una estructura se determinan en su creación.
```{r, echo=TRUE}
vector1 <- c("a", "b", "c")
vector2 <- c("a", "c", "b")

# Aunque los vectores tienen los mismos elementos, su orden es diferente
vector1[2]
vector2[2]

```

Esto es suficiente por ahora. La siguiente ocasión continuaremos con más métodos para crear subconjuntos.

Esta ocasión terminaremos de revisar las formas de extraer subconjuntos de nuestros datos. Puede parecer que le estamos dedicando mucho tiempo a este tema, pero es crucial para ahorrarnos dolores de cabeza en el futuro.

## Subconjuntos por nombre
Podemos usar los nombres de los elementos en una estructura de datos para extraer subconjuntos. Este método es usado principalmente para trabajar con data frames y listas. 

Al igual que con los índices, podemos usar corchetes cuadrados (**[ ]**) para obtener subconjuntos, pero en lugar de escribir un número de índice, escribimos el nombre del elemento que deseamos extraer como una cadena de texto, es decir, entre comillas.

Por ejemplo, usando el mismo data frame que la ocasión anterior.
```{r, echo=TRUE}
mi_df <- data.frame("nombre" = c("Armando", "Elsa", "Ignacio", "Olga"), 
                    "edad" = c(20, 24, 22, 30), "sexo" = c("H", "M", "M", "H"), 
                    "grupo" = c(0, 1, 1, 0))

mi_df["nombre"]

mi_df["grupo"]

```

En una data frame, cada uno de sus elementos representa una columna en los datos, así que en realidad estamos pidiendo a R que nos devuelva las columnas con los nombres que le indicamos.

Podemos extraer más de un elemento si en lugar de una cadena de texto escribimos un vector de texto entre los corchetes.

```{r, echo = TRUE}
# Esto funciona
mi_df[c("edad", "sexo")]

# Esto no funciona como esperamos
mi_df["edad", "sexo"]

# Además, las columnas son devueltas en el orden que las pedimos
mi_df[c("sexo", "edad")]
```

Si pedimos un nombre que no existe en nuestros datos, obtenemos un error.
```{r, echo = TRUE, error=TRUE}
mi_df["calificacion"]
```

Para una lista, el procedimiento es el mismo que con un data frame. En lugar de obtener columnas, obtenemos los elementos contenidos en la lista para los que hemos proporcionado un nombre. 

Una diferencia importante con los data frame es que si pedimos un nombre que no existe en la lista, se nos devuelve **NULL** en lugar de un error.

```{r, echo = TRUE}
mi_lista <- list("uno" = 1, "dos" = "2", "tres" = as.factor(3), 
                 "cuatro" = c(1:4))

mi_lista["dos"]

mi_lista[c("cuatro", "tres")]

mi_lista["cinco"]

```

También podemos usar el signo de dólar (**$**) para extrar subconjuntos usando nombres. 

Este método permite extraer sólo un elemento a la vez y en un data frame, siempre devolverá una columna.
Si lo deseamos, podemos escribir el nombre que nos interesa obtener sin comillas.

```{r, echo = TRUE, error=TRUE}
# Esto funciona
mi_df$nombre

# Esto también funciona
mi_df$"nombre"

# Esto no funciona
mi_df$c("nombre", "edad")

```

Notarás que la salida al usar este método es diferente que si usamos corchetes. Si revisas la **Tarea 01**, verás más ejemplos de este comportamiento.

En pocas palabras, **distintos métodos para obtener subconjuntos pueden devolver resultados diferentes**. Más adelante en este documento veremos porqué ocurre esto 

** Nombres para extraer renglones
De igual manera que con los índices, si escribimos dentro de un corchete nombres separados por comas, R interpretará esto como que estamos buscando elementos en más de una dimensión.

En un data frame, el primer nombre corresponderá a renglones y el segundo a columnas. Esto funciona porque en un data frame los renglones también pueden tener nombre. 

En caso de que pidamos un nombre de renglón que no existe, nos es devuelto **NA**

Por ejemplo, en el conjunto de datos **iris** los nombres de los renglones son igual a su número de renglón.
```{r, echo=TRUE}
# Pedimos el renglón llamado "4"
iris["4", ]

# En este caso, lo anterior es equivalente a pedir el índice cuatro
iris[4, ]
```

Lo anterior nos permite extraer subconjuntos muy específicos de nuestros datos.
```{r, echo=TRUE}
iris["110", "Species"]

iris["15", c("Sepal.Length", "Sepal.Width")]

iris[c("88", "96"), c("Sepal.Length","Sepal.Width")]
```

** Subconjutos por indice y nombre
Al extraer subconjuntos podemos usar tanto índices como nombres dentro del mismo corchete.

Esta es una herramienta muy poderosa al manipular datos pues nos proporciona una flexibilidad para extrar subconjuntos.

Por supuesto, tenemos que seguir las reglas de ambos métodos.
```{r, echo=TRUE}
iris[5:6, "Species"]

iris["76", 2:3]

iris[c(1:2, 149:150), c("Petal.Width", "Species")]
```

Esto no funciona con las listas, Por ser estructuras de datos unidimensionales.


** Subconjuntos con su clase y tipo original: usando el signo de dólar $ y el corchete doble [[ ]]

¿Porqué llamar **mi_df["nombre"]** devuelve un resultado diferente de llamar **mi_df$nombre**?

```{r, echo = TRUE}
mi_df["nombre"]

mi_df$nombre
```

Para entender lo que esta ocurriendo necesitamos recordar que **un data frame está formado por vectores**. Esto vectores nunca dejan de ser vectores, aunque estén contenidos dentro de un data frame. Por lo tanto, es posible extraerlos.

Además, necesitamos entender que **cuando extramos un subconjunto de un objeto usando corchetes, obtenemos como resultado un objeto de su misma clase**.

Esto suena a un trabalenguas, pero todo lo que quiere decir es que extraemos un subconjunto de una lista, obtenemos una lista; si lo hacemos de un data frame, obtenemos un data frame; y lo mismo para todas las estructuras de datos.

Esto lo podemos comprobar fácilmente usando la función **class( )**

```{r, echo = TRUE}
class(mi_df)

class(mi_df["nombre"])
```

Esto cambia cuando usamos el signo de dólar **$** para extraer un subconjunto. **Si usamos un signo de dolar, obtenemos un objeto de la misma clase y tipo que era ese elemento originalmente**. 

En el caso de un data frame, usar el signo de dólar siempre resulta en vectores atómicos.

```{r, echo = TRUE}
class(mi_df$nombre)

class(mi_df$edad)

class(mi_df$sexo)
```

Con las listas, podemos obtener objetos de cualquier clase y tipo.

```{r, echo=TRUE}
# Una lista con una matriz y un data frame.
mi_lista <- list("uno" = matrix(2:2, nrow = 2), 
              "dos" = data.frame("a" = 1:2, "b" = 3:4))

# Devuelve una lista
class(mi_lista["uno"])

# Devuelve una matriz
class(mi_lista$uno)

# Devuelve un data frame
class(mi_lista$dos)
```

Otra manera de extraer elementos de un objeto con su clase original es usar corchetes dobles **[[ ]]**. 

La ventaja de usar este método es que podemos usar índices y nombres dentro de los corchetes dobles, lo que nos da acceso a una mayor flexibilidad para extraer subconjuntos, además de que nos permite usarlos en estructuras de datos que tienen elementos sin nombre.

```{r, echo=TRUE}
mi_df[["edad"]]

mi_df[[2]]

mi_matriz <- matrix(1:9, nrow = 3, ncol = 3)

mi_matriz

mi_matriz[[1, 2]]
```

Sin embargo, no podemos usar vectores dentro los corchetes dobles para extraer subconjuntos, pues este método busca un elemento a la vez.

```{r, echo=TRUE, error=TRUE}
mi_matriz[[c(1, 3), 2]]
```

Obtener un objeto del tipo correcto al extraer un subconjunto es sumamente importante, en particular si deseamos usar este subconjunto para realizar otras operaciones.

Por ejemplo, si queremos obtener la media de la columna **Sepal.Width** del conjunto de datos iris, usamos la función **mean( )**. Sin embargo, esta función nos pide que demos como argumento un vector, de modo que debemos estar atentos a cómo extraemos la columna que nos interesa.

```{r, echo = TRUE}
# Esto no funciona, porque estamos extrayendo un data frame
mean(iris["Sepal.Width"])

# Esto sí funciona
mean(iris$Sepal.Width)

# Esto también funciona
mean(iris[["Sepal.Width"]])
```

## Subconjuntos de un data frame usando condicionales

Supongamos que nos interesa obtener un subconjunto de datos que cumplen con una o más condiciones específicas.

Por ejemplo, queremos obtener todos los datos de una encuesta que corresponden a mujeres, o a personas que viven en una entidad específica o que tienen un ingreso superior a la media.

Si tenemos columnas que contengan esa información en nuestro conjunto de datos, podemos extraer subconjuntos usando condicionales dentro de los corchetes.

Esta operación tiene la siguiente estructura.

** objeto[condicion, columnas_devueltas] **

Veamos un ejemplo.

Extraeremos del conjunto iris...

... todos los casos en los que el ancho del pétalo es mayor a 2. 

```{r, echo = TRUE}
iris[iris["Petal.Width"] > 2, ]
```

... todos los casos en los que la especie sea "setosa"

```{r}
iris[iris[["Species"]] == "setosa", ]
```

... la especie de los casos en que los que el ancho del sépalo sea menor a 3.

```{r}
iris[iris$Sepal.Width < 3, "Species"]
```

... el ancho y largo del pétalo de los casos en los que el largo del sépalo es mayor o igual a 7.2.

```{r}
iris[iris["Sepal.Length"] >= 7.2, c("Petal.Length", "Petal.Width")]
```

¿Qué es lo que está ocurriendo?

Dentro del corchete escribimos antes de una coma un subconjunto, al cual aplicamos una operación relacional. Todos los renglones en los que el resultado de esta operación sea **TRUE**, formarán parte de nuestro subconjunto.

Si no indicamos qué columnas queremos que se nos devuelvan, obtendremos todas. De esta manera podemos extraer subconjuntos que cumplen una condición, pero sólo para una columna específica.

Para entender porqué escribimos una operación relacional aplicada a un subconjunto dentro de los corchetes, nos conviene saber que las operaciones relacionales también se vectorizan.

Si al vector **iris$Petal.Width** aplicamos la operación **> 6**, esta se aplicará a todos sus elementos, devolviendo **TRUE** o **FALSE**, según corresponda.

```{r, echo = TRUE}
as.vector(iris["Petal.Width"] > 6)
```

Así, lo que pedimos antes de la coma dentro de un corchete, son todos los renglones para los que la condición es verdadera.

Si quisieras, podrías elegir manualmente renglones de un data frame usando TRUE y FALSE.
```{r, echo=TRUE}
# EL vector de datos lógicos se reciclará, así que obtendremos uno de cada cinco elementos
iris[c(TRUE, FALSE, FALSE, FALSE, FALSE), ]
```

<!--chapter:end:07-subconjuntos.Rmd-->

# Funciones
Después de que hemos superado la parte más básica aburrida de R podemos pasar a lo divertido: programar. Es decir, lograr que R realice tareas de manera automatizada a partir de nuestras propias especificaciones.

Para eso, tenemos que conocer las funciones definidas por el usuario.

## ¿Por qué necesitamos crear nuestrar propias funciones?
La instalación base de R tiene suficientes funciones para que realicemos todas las tareas básicas de análisis de datos, desde importar información hasta crear documentos para comunicarla (¡este librp ha sido creado con R!).

Sin embargo, constantemente necesitamos realizar tareas para las que no existe una función que resuelva un problema en particular. O existen funciones que nos dan una solución, pero que requieren de combinarlas o utilizarlas en sucesión, complicando el código que debemos escribir para análisis repetidos.

Ilustremos lo anterior con un caso. Supongamos que nuestro jefe nos ha pedido crear un histograma con datos de edad que hemos recogido en una encuesta. Esto es sencillo de resolver, la función `hist()` hace exactamente esto, basta con proporcionarle un vector numérico para que nos devuelva un gráfico.
```{r, echo=TRUE}
# Simulamos datos sacados de una distribución normal.
set.seed(173)
edades<- rnorm(1500, mean = 15, sd = .75)

# Un vistazo a los primeros diez datos
edades[1:10]

# Histograma
hist(edades)
```

Nuestro jefe está satisfecho... pero (siempre hay un pero) le gustaría que en el histograma se muestre la media y desviación estándar de los datos. ¡Ah! Y que tenga un título descriptivo. Y que los ejes  estén etiquetados en español. Y que las barras del histograma sean de color dorado.

¡No hay problema! Podemos calcular la media de los datos usando la función `mean()`, la desviación estándar con `sd()` y podemos agregar los resultados de este cálculo al histograma usando la función `abline()`. Para agregar título, etiquetas en español y colores al histograma sólo basta agregar los argumentos apropiados a la función `hist()`.
```{r, echo=TRUE}
# Calculamos media y desviación estándar
media <- mean(edades)
desv_est <- sd(edades)

# Agregamos líneas, media de rojo y desviación estándar con azúl.
hist(edades, main = "Edades", xlab = "Datos", ylab = "Frecuencia", col = "gold")
abline(v = media, col = "red")
abline(v = media + (desv_est * c(1, -1)), col = "blue")
```

¡Estupendo! Nuestro jefe ahora sí que ha quedado complacido. Tanto, que nos pide que hagamos un histograma igual para todas las variables numéricas de esa encuesta. 

¿Para **todas** las cincuenta variables? Le preguntas a tu jefe, aunque ya sabes qué te va a responder.

Sí, para **TODAS**, te contesta, justo como esperabas. Además las quiere para el viernes antes de las 2. Después de decirte esto y antes de que puedas preguntar nada más, parte muy apresurado a otra reunión urgentísima.

Para cumplir con esta tarea podríamos usar el código que ya hemos escrito. Simplemente lo copiamos y pegamos cincuenta veces, cambiando los valores para cada una de variables que nos han pedido.

Sin embargo, esta es una manera de hacer las cosas que propicia errores y es difícil de corregir y actualizar.

Si copias el código anterior cincuenta veces, tendrás un script con más de **400 líneas**. Si en algún momento te equivocas porque escribiste "Enceusta" en lugar de "Encuesta", incluso con las herramientas de búsqueda de RStudio, encontrar donde está el error será una tarea larga y tediosa.

Y si tu jefe en esta caso hipotético quiere que agregues, quites o modifiques tu histograma, tendrás que hacer el cambio cincuenta veces, una para cada copia del código. De nuevo, con esto se incrementa el riesgo de que ocurran errores y dificulta localizarlos.

¿No sería mejor tener una función que se llamara crear_histograma e hiciera todo lo que queremos con una sóla instrucción?

Es en situaciones como esta en las que se hace evidente la necesidad de crear nuestras propias funciones, capaces de realizar una tarea específica a nuestros probolemas, y que pueda usarse de manera repetida. Con esto reducimos errores, facilitamos hacer correcciones o cambios y nos hacemos la vida más fácil, a nosotros y a quienes usen nuestro código.

## Definiendo funciones en R
Las funciones definidas por el usuario son creadas usando el siguiente modelo. 
```{r, echo=TRUE}
nombre <- function(argumentos) {
  cuerpo (operaciones)
}
```

Cuando asignamos una función a un nombre decimos que hemos definido una función.

El nombre que asignamos a una función nos permite llamarla y hacer referencia a ella. Podemos asignar la misma función a diferentes nombres o cambiar la función que ya le hemos asignado a un nombre. Como siempre, es recomendable elegir nombres claros, no ambiguos y descriptivos. 

Una vez que la función tiene nombre, podemos llamarla usando la forma `nombre()`, como con las funciones por defecto de R.

Los argumentos son las variables que necesita  la función para realizar sus operaciones. Aparecen entre paréntesis, separados por comas. Los valores de los argumentos son asignados por el usuario cada vez que ejecuta una función. Esto permite que usemos nuestras funciones en distintas situaciones con diferentes datos y especificaciones.

Dentro de la función, los argumentos se convertirán en el nombre de los valores que asignemos a ellos. Los argumentos pueden ser datos, estructuras de datos, conexiones a archivos u otras funciones y todos deben tener nombres diferentes.

El cuerpo de la función contiene, entre llaves, todas las operaciones que se ejecutaran cuando la función sea llamada. El cuerpo de una función puede ser tan sencillo o complejo como nosotros deseemos, incluso podemos definir funciones dentro de una función (y definir funciones dentro de una función dentro de otra función, aunque esto se vuelve confuso rápidamente). 

Si el código del cuerpo de la función tiene errores, la función no se ejecutará y nos será devuelto un mensaje de error **al ejecutarla**. R no nos avisa si nuestra función va a funcionar o no hasta que intenta correrla. 

Una ventaja de usar RStudio es que nos indica errores de sintaxis en nuestro código, lo cual nos puede salvar de cometer algunos errores. Sin embargo, hay problemas que esta característica de RStudio no detecta, como que intentemos realizar operaciones inválidas o que intentemos coerciones imposibles.

Para ver esto en acción, crearemos una función sencilla para obtener el área de un cuadrilátero.

## Nuestra primera función
Partimos de que podemos calcular el área de un cuadrilátero con el algoritmo: `media_de_lado x medida_de_lado`.
```{r, echo=TRUE}
area_cuad <- function(lado1, lado2) {
  lado1 * lado2
}
```

Los partes de nuestra función son:

* Nombre: area_cuad. 
* Argumentos: lado1, lado2. Estos son los datos que necesita la función para calcular el área, representan el largo de los lados de un cuadrilátero.
* Cuerpo: La operación `lado1 * lado2`, escrita de manera que R pueda interpretarla.

Ejecutaremos nuestra función para comprobar que funciona. Nota que lo único que estamos haciendo cada que la llamamos es cambiar la medida de los lados del cuadrilátero para el que calcularemos un área, en lugar de escribir la operación `lado1 * lado2` en cada ocasión.

```{r, echo=TRUE}
area_cuad(lado1 = 4, lado2 = 6)

area_cuad(lado1 = 36, lado2 = 36)
```

En cada llamada a nuestra función estamos asignando distintos valores a los argumentos usando el signo de igual **=**. Si nos falta asignar valores a un argumento, se nos mostrará un error

```{r, echo=TRUE, error=TRUE}
area_cuad(lado1 = 14)
```

En R, podemos especificar los argumentos por posición. El orden de los argumentos se determina cuando creamos una función. 

En este caso, nosotros determinamos que el primer argumento que recibe area_cuad es lado1 y el segundo es lado2. Así, podemos escribir lo siguiente y obtener el resultado correcto.
```{r, echo=TRUE}
area_cuad(128, 64)
```
Esto es equivalente a escribir `lado1 = 128, lado2 = 64`.

Con esto hemos definido nuestra primera función.

Podemos crear ahora una función ligeramente más compleja para calcular el volumen de un prisma rectangular 

Siguiendo la misma lógica de transformar un algoritmo a código de R, podemos crear una función con el  algoritmo: `medida_de_arista x medida_de_arista x medida_de_arista`
```{r, echo=TRUE}
# Definimos la función
area_prisma <- function(arista1, arista2, arista3) {
  arista1 * arista2 * arista3
}

# Probamos la función
area_prisma(3, 6, 9)
```

También podemos escribir esta función aprovechando la función **area_cuad** que ya hemos definido.

```{r, echo=TRUE}
area_prisma <- function(arista1, arista2, arista3) {
  area_cuad(arista1, arista2) * arista3
}

area_prisma(3, 6, 9)
```

Creo que estamos listos para definir una función para crear histogramas con las características que nos pidió nuestro hopotético jefe.

## Nuestra función crear_histograma
Ya hemos decidido (bueno, lo decidí yo) el nombre que tendrá la función que definiremos. 

```{r, echo=TRUE}
crear_histograma <- function() {

}
```

Nos falta especificar cuáles serán sus argumentos y qué operaciones contendrá su cuerpo.

Para que esta función ejecute lo que queremos necesita de dos cosas:

* Los datos que serán graficados.
* El nombre de la variable graficada

Por lo tantos, nuestros argumentos serán:

* datos
* nombre

```{r, echo=TRUE}
crear_histograma <- function(datos, nombre) {
  
}
```

Como ya sabemos las operaciones que queremos realizar, al haber elaborado nuestro histograma antes, es cuestión de incluirlas al cuerpo de nuestro función.

Reemplazaremos las variables que hacen referencia a un objeto en particular por el nombre de nuestros argumentos.

En este caso, cambiamos la referencia a la variable **edades** por referencias al argumento **datos** y la referencia a **"Edades"**, que usaremos como título del histograma, por una referencia al argumento **nombre**.
```{r, echo=TRUE}
crear_histograma <- function(datos, nombre) {
  media <- mean(datos)
  desv_est <- sd(datos)
  
  hist(datos, main = nombre, xlab = "Datos", ylab = "Frecuencia", col = "gold")
  abline(v = media, col = "red")
  abline(v = media + (desv_est * c(1, -1)), col = "blue")
}
```

Probemos nuestra función usando datos distintos. En este caso, de ingreso al mes.
```{r, echo=TRUE}
ingreso <- rnorm(1500, mean = 15000, sd = 5000)

crear_histograma(ingreso, "Ingreso")
```

Luce bien. Probemos ahora con datos sobre el peso de las personas.
```{r, echo=TRUE}
peso <- rnorm(75, mean = 60, sd = 15)

crear_histograma(peso, "Peso")
```

Por supuesto, las funciones que nosotros mismo definimos pueden devolvernos errores. Por ejemplo, si introducimos datos que no son apropiados para las operaciones a realizar, nuestra función no se ejecutará correctamente.
```{r, echo=TRUE, error = TRUE}
crear_histograma("Cuatro", ingreso)
```

Por esta razón es importante crear **documentación** para las funciones que hayas creado. Puede ser tan sencilla como una explicación de qué hace la función y qué tipo de datos necesita para realizar sus operaciones.

Puede parecerte increíble, pero tu Yo de un mes en el futuro puede haber olvidado por completo qué hizo tu Yo del día de hoy, así que la documentación es una manera de recordar tu trabajo.

```{r, echo=TRUE}
# crear_histograma
# Devuelve un histograma con lineas indicando la media y desviación estándar de un vector de datos numérico
# Argumentos:
# - datos: Un vector numérico.
# - nombre: Una cadena de texto.
```

¡Listo, tenemos una función que hace justo lo que deseamos en una línea de código!

Ahora, podremos cumplir con la solicitud de nuestro jefe ficticio usando cincuenta llamadas a una función en lugar de corriendo más de cuatrocientas líneas de código. Aún es una cantidad considerable de trabajo, pero es mucho menos que antes y con una menor probabilidad de cometer un error que no podamos corregir fácilmente.

Además, si a nuestro jefe se le ocurren nuevas características para los histogramas, basta con cambiar el cuerpo de nuestra función una vez y esto se verá reflejado en nuestro cincuenta casos al correr de nuevo el código.

Por ejemplo, supongamos que nuestro jefe también quiere que el histograma muestre la mediana de nuestros datos y que las barras sean de color naranja. Basta con hacer un par de cambios.
```{r, echo=TRUE}
crear_histograma <- function(datos, nombre) {
  media <- mean(datos)
  desv_est <- sd(datos)
  mediana <- median(datos)
  
  hist(datos, main = nombre, xlab = "Datos", ylab = "Frecuencia", col = "orange")
  abline(v = media, col = "red")
  abline(v = media + (desv_est * c(1, -1)), col = "blue")
  abline(v = mediana, col = "green")
}

crear_histograma(peso, "Peso con mediana")
```

Quizás estés pensando que escribir una función cincuenta veces es demasiado y aún se presta a cometer errores. Tienes razón, podríamos hacer más breve nuestro código y menos susceptible a equivocaciones. Si tan sólo hubiera una manera de **aplicar** una función muchas veces sin escribir tanto...

Pero eso lo veremos en las siguientes sesiones.

<!--chapter:end:08-funciones.Rmd-->

# Estructuras de control
Como su nombre lo indica, las estructuras de control nos permiten controlar la manera en que se ejecuta nuestro código. 

Las estructuras de control establecen **condicionales** en nuestros código. Por ejemplo, qué condiciones deben cumplirse para realizar una operación o qué debe ocurrir para ejecutar una función.

Esto es de gran utilidad para determinar la lógica y el orden en que ocurren las operaciones, en especial al definir funciones.

Las estructuras de control más usadas en R son las siguientes.

| Estructura de control | Descripción
| ---                   |---
| `if`, `else`          | Si, de otro modo
| `for`                 | Para cada uno en
| `while`               | Mientras
| `break`               | Interrupción
| `next`                | Siguiente

## if, else
`if` (si) es usado cuando deseamos que una operación de ejecute únicamente cuando una condición se cumple. 

`else` (de otro modo) es usado para indicarle a R qué hacer en caso de la condición de un `if` no se cumpla. 

Un `if` es la manera de decirle a R: 

* **SI** esta condición es cierta, **ENTONCES** haz estas operaciones.

El modelo para un `if` es:
```{r, eval=FALSE}
if(Condición) {
  operaciones_si_la_condición_es_TRUE
}
```

Si la condición se cumple, es decir, es verdadera (`TRUE`), entonces se realizan las operaciones. En caso contrario, no ocurre nada y el código con las operaciones no es ejecutado.

Por ejemplo, le pedimos a R que nos muestre el texto "Verdadero" si la condición se cumple.
```{r, echo=TRUE}
# Se cumple la condición y se muestra "verdadero"
if(4 > 3) {
  "Verdadero"
}

# No se cumple la condición y no pasa nada
if(4 > 5) {
  "Verdadero"
}
```

`else` complementa un `if`, pues indica qué ocurrirá cuando la condición no se cumple, es falsa (`FALSE`), en lugar de no hacer nada.

Un `if` con `else` es la manera de decirle a R:

* **SI** esta condición es es cierta, **ENTONCES** haz estas operaciónes, **DE OTRO MODO** haz estas otras operaciones.

El modelo para un **if** con un **else** es:
```{r, eval=FALSE}
if(condición) {
  operaciones_si_la_condición_es_TRUE
} else {
  operaciones_si_la_condición_es_FALSE
}
```

Usando los ejemplos anteriores, podemos mostrar "Falso" si no se cumple la condición, en lugar de que no ocurra nada.

```{r, echo=TRUE}
# Se cumple la condición y se muestra "Verdadero"
if(4 > 3) {
  "Verdadero"
} else {
  "Falso"
}

# No se cumple la condición y se muestra "Falso"
if(4 > 5) {
  "Verdadero"
} else {
  "Falso"
}
```

### Usando if y else
Para ilustrar el uso de `if` `else` definiremos una función que calcule el promedio de calificaciones de un estudiante y, dependiendo de la calificación calculada, nos devuelva un mensaje específico.

Empezamos definiendo una función para calcular promedio. En realidad, sólo es la aplicación de la función `mean()` ya existente en R *base*, pero la ampliaremos después.
```{r, echo=TRUE}
promedio <- function(calificaciones) {
  mean(calificaciones)
}

promedio(c(6, 7, 8, 9, 8))
promedio(c(5, 8, 5, 6, 5))
```

Ahora deseamos que esta función nos muestre si un estudiante ha aprobado o no.

Si asumimos que un estudiante necesita obtener 6 o más de promedio para aprobar, podemos decir que:

* **SI** el promedio de un estudiante es igual o mayor a 6, **ENTONCES** mostrar "Aprobado", **DE OTRO MODO**, mostrar "Reprobado".

Aplicamso esta lógica con un `if`,  `else` en la función `promedio()`.
```{r, echo=TRUE}
promedio <- function(calificaciones) {
  media <- mean(calificaciones)
  
  if(media >= 6) {
    print("Aprobado")
  } else {
    print("Reprobado")
  }
}
```

Probemos nuestra función
```{r, echo=TRUE}
promedio(c(6, 7, 8, 9, 8))
promedio(c(5, 8, 5, 6, 5))
```

Está funcionando, aunque los resultados podrían tener una mejor presentación.

Usaremos la función `paste0()` para pegar el promedio de calificaciones, como texto, con el resultado de "Aprobado" o "Reprobado". Esta función acepta como argumentos cadenas de texto y las pega (concatena) entre sí, devolviendo como resulta una nueva cadena.

Primero concatenaremos la palabra "Calificación: " a la media obtenida con la función `promedio()` y después el resultado de esta operación con la palabra "aprobado" o "reprobado", según corresponda.
```{r, echo=TRUE}
promedio <- function(calificaciones) {
  media <- mean(calificaciones)
  texto <- paste0("Calificación: ", media, ", ")
  
  if(media >= 6) {
    print(paste0(texto, "aprobado"))
  } else {
    print(paste0(texto, "reprobado"))
  }
}
```

Pongamos a prueba nuestra función.
```{r}
promedio(c(6, 7, 8, 9, 8))
promedio(c(5, 8, 5, 6, 5))
```

Por supuesto, como lo vimos en el capítulo sobre [funciones](#funciones), podemos hacer aún más compleja a `promedio()`, pero esto es suficiente para conocer mejor las aplicaciones de `if` `else`.

### ifelse
La función `ifelse( )` nos permite vectorizar `if, else`. En lugar de escribir una línea de código para cada comparación, podemos usar una sola llamada a esta función, que se aplicará a todos los elementos de un vector.

Si intentamos usar `if` `else` con un vector, se nos mostrará una advertencia.
```{r}
if(1:10 < 3) {
  "Verdadero"
}
```
Este mensaje nos dice que sólo se usará el primer elemento del vector para evaluar su la condición es verdadera y lo demás será ignorado.

En cambio, con `ifelse` se nos devolverá un valor para cada elemento de un vector en el que la condición sea `TRUE`, además nos devolvera otro valor para los elementos en que la condición sea `FALSE`. 

Esta función tiene la siguiente forma.
```{r, echo=TRUE, eval=FALSE}
ifelse(vector, valor_si_TRUE, valor_si_FALSE)
```

Si intentamos el ejemplo anterior con `ifelse()`, se nos devolverá un resultado para cada elemento del vector, no sólo del primero de ellos.
```{r, echo=FALSE}
ifelse(1:10 < 3, "Verdadero", "Falso")
```
De este modo podemos usar `ifelse()` para saber si los números en un vector son pares o nones.
```{r, echo=TRUE}
num <- 1:8

ifelse(num %% 2 == 0, "Par", "Non")
```

También tenemos la opción de crear condiciones más complejas usando operadores Booleanos.

Por ejemplo, pedimos sólo los números que son exactamente divisibles entre 2 y 3.
```{r, echo=TRUE}
num <- 1:20

ifelse(num %% 2 == 0 & num %% 3, "Divisible", "No divisible")
```

Desde luego, esto es paricularmente útil para recodificar datos.
```{r, echo = TRUE}
num <- c(0, 1, 0, 0, 0, 1, 1)

num <- ifelse(num == 0, "Hombre", "Mujer")

num
```


## for 
La estructura `for` nos permite ejecutar un bucle (*loop*), realizando una operación para cada elemento de un conjunto de datos.

Su estructura es la siguiente:
```{r, echo=TRUE, eval=FALSE}
for(elemento in objeto) {
  operacion_con_elemento
}
```

Con lo anterior le decimos a R:

* **PARA** cada elemento **EN** un objeto, haz la siguiente operación.

Al escribir un bucle `for` la parte que corresponde al **elemento** la podemos llamar como nosotros deseemos, pero la parte que corresponde al **objeto** debe ser el nombre de un objeto existente.

Los dos bucles siguientes son equivalentes, sólo cambia el nombre que le hemos puesto al **elemento**.
```{r, eval = FALSE}
objeto <- 1:10

for(elemento in objeto) {
  operacion_con_elemento
}

for(i in objeto) {
  operacion_con_elemento
}
```

Tradicionalmente se usa la letra **i** para denotar al elemento, pero nosotros usaremos nombres más descriptivos en este capítulo.


### Usando for
Vamos a obtener el cuadrado de cada uno de los elementos en un vector numérico del 1 al 6, que representa las caras de un dado.
```{r, echo=TRUE} 
dado <- 1:6

for(cara in dado) {
  dado ^ 2 
}
```

Notarás que al ejecutar el código anterior parece que no ha ocurrido nada. En realidad, sí se han realizado las operaciones, pero R no ha devuelto sus resultados.

Las operaciones en un `for` se realizan pero sus resultados nunca son devueltos automáticamente, es necesario pedirlos de manera explícita.

A diferencia de otros lenguajes de programación en los que pedimos los resultados de un bucle con `return()`, en R este procedimiento sólo funciona con funciones.

Una solución para mostrar los resultados de un bucle `for` es usar la función `print()`.
```{r, echo=TRUE}
for(cara in dado) {
  print(cara ^ 2)
}
```

Comprobamos que la operación ha sido realizada a cada elemento de nuestro objeto. Sin embargo, usar `print()` sólo mostrará los resultados de las operaciones en la consola, no los asignará a un objeto.

Si deseamos asignar los resultados de un bucle `for` a un objeto, usamos [índices](##indices). 

Aprovechamos que el primer elemento en un bucle siempre es identificado con el número **1** y que continuará realizando operaciones hasta llegar al total de elementos que hemos especificado.
```{r, echo=TRUE}
for(numero in 1:10) {
  print(numero)
}
```

En nuestro ejemplo, pasamos por los valores de dado, cara por cara. La primera cara será igual a **1**, la segunda a **2**, y así sucesivamente hasta el **6**. 

Podemos usar estos valores para asignar cada valor resultante de nuestras operaciones a una posición específica en un vector, incluso si este está vacio.

Creamos un vector vacio, asignándole como `NULL` como valor.
```{r, echo=TRUE}
mi_vector <- NULL
```

Ejecutamos nuestro bucle.
```{r, echo=TRUE}
for(cara in dado) {
  mi_vector[cara] <- cara ^ 2
}
```

Aunque no fueron mostrados en la consola, los resultados han sido asignados al objeto `mi_vector`.
```{r, echo=TRUE}
mi_vector
```

### for y vectorización
Notarás que el resultado que obtuvimos usando **for** es el mismo que si vectorizamos la operación.
```{r, echo=TRUE}
dado ^ 2
```

Dado que en R contamos con vectorización de operaciones, que podemos usar las funciones de [la familia apply](#la-familia-apply) (discutido en siguiente capítulo) en objetos diferentes a vectores y que la manera de recuperar los resultados de un `for` es un tanto laboriosa, este tipo de bucle no es muy popular en R. 

En R generalmente hay opciones mejores, en cuanto a simplicidad y velocidad de cómputo, que un bucle `for`.

Sin embargo, es conveniente que conozcas esta estructura de control, pues hay ocasiones en la que es la mejor herramienta para algunos problemas específicos.

## while
Este es un tipo de bucle que ocurre **mientras** una condición es verdadera (`TRUE`). La operación se realiza hasta que se se llega a cumplir un criterio previamente establecido.

El modelo de **while** es:
```{r, echo=TRUE, eval=FALSE}
while(condicion) {
  operaciones
}
```

Con esto le decimos a R:

* **MIENTRAS** esta condición sea **VERDADERA**, haz estas operaciones.

La condición generalmente es expresada como el resultado de una o varias operaciones de comparación, pero también puede ser el resultado de una función.

### Usando while
Probemos sumar `+1` a un valor, mientras que este sea menor que 5. Al igual que con `for`, necesitamos la función `print()` para mostrar los resultados en la consola.
```{r, echo=TRUE}
umbral <- 5
valor <- 0

while(valor < umbral) {
  print("Todavía no.")
  valor <- valor + 1
}
```

¡Ten cuidado con crear bucles infinitos! Si ejecutas un `while` con una condición que nunca será `FALSE`, este nunca se detendrá.

Si corres lo siguiente, presiona la tecla **ESC** para detener la ejecución, de otro modo, correra por siempre y puede llegar a congelar tu equipo.
```{r, echo=TRUE, eval=FALSE}
while(1 < 2) {
  print("Presiona ESC para detener")
}
```

El siguiente es un error común. Estamos sumando 1 a `i` con cada iteración del bucle, pero como no estamos asignando este nuevo valor a `i`, su valor se  mantiene igual, entonces la condición nunca se cumplirá y el bucle será infinito.

De nuevo, si corres lo siguiente, presiona la tecla **ESC** para detener la ejecución.
```{r, echo=TRUE, eval=FALSE}
i <- 0
while(i < 10) {
  i + 1
}
```

Un uso común de **while** realizae operaciones que queremos detener cuando se cumple una condición, pero desconocemos cuándo ocurrirá eso.

Supongamos que, por alguna razón queremos sumar calificaciones, del 1 al 10 al azar, hasta llegar a un número que mayor o igual a 50. Además nos interesa saber cuántas calificaciones sumaron y cuál fue el resultado al momento de cumplir la condición.

Para obtener números al azar del 1 al 10, usamos la función `sample()`. Esta función va a tomar una muestra al azar de tamaño igual a 1 (argumento `size`) de un vector del 1 al 10 (argumento `x`) cada vez que se ejecute.

Por lo tanto, cada vez que corras el ejemplo siguiente obtendrás un resultado distinto, pero siempre llegarás a un valor mayor a 50.

Creamos dos objetos, `conteo` y `valor`. Les asignamos el valor 0.
```{r, echo=TRUE}
conteo <-  0
valor <- 0
```

Nuestro `while` hará dos cosas. 

Primero, tomará un numero al azar del 1 al 10, y lo sumará a `valor`. Segundo, le sumará 1 a `conteo` cada que esto ocurra, de esta manera sabremos cuantas iteraciones ocurrieron para llegar a un valor que no sea menor a 50.
```{r,echo=TRUE}
while(valor < 50) {
  valor <- valor + sample(x = 1:10, size = 1)
  conteo <- conteo + 1
}
```

Aunque no son mostrados en la consola los resultados son asignados a los objetos `valor`y `conteo`
```{r, echo=TRUE}
valor
conteo
```

Por último, si intentamos ejecutar un `while` para el que la condición nunca es igual a `TRUE`, este no realizará ninguna operación.
```{r, echo=TRUE}
conteo <- 0

while("dado" == "ficha") {
  conteo <- conteo + 1
}

conteo
```

## break y next
`break` y `next`  son  **palabras reservadas** en R, no podemos asignarles nuevos valores y realizan una operación específica cuando aparecen en nuestro código.

`break` nos permite **interrumpir** un bucle, mientras que `next` nos deja avanzar a la **siguiente** iteración del bucle, "saltandose" la actual. Ambas funcionan para `for` y `while`.

### Usando break
Para interrumpir un bucle con `break`, necesitamos que se cumpla una condición. Cuando esto ocurre, el bucle se detiene, aunque existan elementos a los cuales aún podría aplicarse.

Interrumpimos un `for` cuando `i` es igual a 3, aunque aún queden 7 elementos en el objeto.
```{r, echo=TRUE}
for(i in 1:10) {
  if(i == 3) {
    break
  }
  print(i)
}
```

Interrumpimos un `while` antes de se cumpla la condición de que `numero` sea mayor a 5, en cuanto este tiene el valor de 15.
```{r, echo=TRUE}
numero <- 20

while(numero > 5) {
  if(numero == 15) {
    break
  }
  numero <- numero - 1
}

numero
```

Como habrás notado, la  aplicación de `break` es muy similar a `while`, realizar una operación hasta que se cumple una condición, y ambos pueden usarse en conjunto.

### Usando next
Por su parte, usamos next para "saltarnos" una iteración en un bucle. Cuando la condición se cumple, esa iteración es omitida. 
```{r, echo=TRUE}
for(i in 1:4) {
  if(i == 3) {
    next
  }
  print(i)
}
```

Estas dos estructuras de control nos dan uncontrol fino sobre nuestro código. aunque los dos ejemplos de arriba son con **for**, también funcionan con **while** y **repeat**. 

En realidad, **break** es indispensable en **repeat**.

## repeat
Este es un bucle que se llevará a cabo el número de veces que especifiquemos, usando un `break` para detenerse. `repeat` asegura que las operaciones que contiene sean iteradas al menos en una ocasión.

La estructura de **repeat** es el siguiente:
```{r, echo=TRUE, eval=FALSE}
repeat {
  operaciones
  
  un_break_para_detener
}
```

Si no incluimos un `break`, el bucle se repetirá indefinidamente y sólo lo podremos detener pulsando la tecla ESC, así que hay que tener cuidado al usar esta estructura de control.

Por ejemplo, el siguiente `repeat` sumará `+1` a `valor` hasta que este sea igual a cinco, entonces se detendrá.
```{r, echo=TRUE}
valor <-  0
mi_vector <- NULL

repeat{
  valor <- valor + 1
  if(valor == 5) {
    break
  }
}

# Resultado
valor
```

Este tipo de bucle es quizás el menos utilizado de todos, pues en R existen alternativas para obtener los mismos resultados de manera más sencilla y sin el riesgo de crear un bucle infinito. Sin embargo, hay casos muy específicos en los que es la mejor opción.

<!--chapter:end:09-estructuras-control.Rmd-->

# La familia apply
La familia de funciones `apply` es usada para aplicar una función a cada elemento de una estructura de datos. En particular, es usada para aplicar funciones en matrices, data frames, arrays y listas.

Con esta familia de funciones podemos automatizar tareas complejas usando poca líneas de código y es una de las características distintivas de R como lenguaje de programación.

La familía de funciones `apply` es una expresión de los rasgos del paradigma funcional de programación presentes en R. Sobre esto no profundizaremos demasiado, pero se refiere saber que en R las funciones son "ciudadanos de primera", con la misma importancia que los objetos, y por lo tanto, operamos en ellas. 

La familia de funciones apply no sólo recibe datos como argumentos, también recibe funciones.

### Un recordatorio sobre vectorización
Para entender más fácilmente el uso de la familia apply, recordemos la [vectorización de operaciones](###vectorización-de-operaciones).

Hay operaciones que, si las aplicamos a un vector, son aplicadas a todos sus elementos.
```{r, echo=TRUE}
mi_vector <- 1:10

mi_vector

mi_vector ^ 2
```

Lo anterior es, generalmente, preferible a escribir una operación para cada elemento o a usar un bucle **for**, como se describió en  el capítulo sobre [estructuras de control](#estructuras-de-control).

Como todo lo que ocurre en R es una función, podemos decir que **al vectorizar estamos aplicando una función a cada elemento de un vector**. La familia de funciones **apply** nos permite implementar esto en estructuras de datos distintas a los vectores.

### Las funciones de la familia apply
La familia apply esta formada por las siguientes funciones:

* `apply()`
* `eapply()`
* `lapply()`
* `mapply()`
* `rapply()`
* `sapply()`
* `tapply()`
* `vapply()`

Es una familia numerosa, pues  variedad de funciones se debe a que varias de ellas tienen aplicaciones sumamente específicas.

Todas las funciones de esta familia tienen una característica en común: **reciben como argumentos a un objeto y al menos una función**. 

Hasta ahora, todas las funciones que hemos usado han recibido como argumentos estructuras de datos, sean vectores, data frames o de otro tipo. Las funciones de la familia apply tienen la particularidad que pueden recibir a otra función como un argumento. Lo anterior puede sonar confuso, pero es más bien intuitivo al verlo implementado.

Nosotros trabajaremos con las funciones más generales y de uso común de esta familia:

* `apply()`
* `lapply()`

Estas dos funciones nos permitiran solucionar casi todos los problemas a los que nos encontremos. Además, conociendo su uso, las demás funciones de la familia **apply** serán relativamente fáciles de entender.

## apply
`apply` aplica una función a todos los elementos de una **matriz**.

La estructura de esta función es la siguiente.
```{r, eval = F}
apply(X, MARGIN, FUN)

```

`apply` tiene tres argumentos:

* `X`: Una matriz o un objeto que pueda coercionarse a una matriz, generalmente, un data frame.
* `MARGIN`: La dimensión (margen) que agrupará los elementos de la matriz `X`, para aplicarles una función. Son identificadas con números, **1** son renglones y **2** son colummnas.
* `FUN`: La función que aplicaremos a la matriz `X` en su dimención `MARGIN`.

### ¿Qué es X
`X` es una matriz o cualquier otro objeto que sea posible coercionar a una matriz. Esto es, principalmente, vectores y data frames. 

Recuerda que puedes coercionar objetos a matriz usando `as.matrix()` y puedes comprobar si un objeto es de esta clase con `is.matrix()`.
```{r, echo = TRUE}
# Creamos un data frame
mi_df <- data.frame(v1 = 1:3, v2 = 4:6)

mi_df

# Coerción a matriz
mi_matriz <- as.matrix(mi_df)

# Verificamos que sea matriz
is.matrix(mi_matriz)

# Resultado
mi_matriz
```



Aunque tambien podemos coercionar listas y arrays a matrices, los resultados que obtenemos no siempre son apropiados para `apply()`, por lo que no es recomendable usarl estos objetos como argumentos.

### ¿Qué es MARGIN?
Recuerda que las matrices y los data frames están formadas por vectores y que estas estructuras tienen dos dimensiones, ordenadas en renglones y columnas. Esto lo vimos en en [Matrices y arrays](##matrices-y-arrays) y [Data frames](##data-frames).

Para `MARGIN`:

* 1 es renglones.
* 2 es columnas.

Por ejemplo, podemos usar `apply()` para obtener la sumatoria de los elementos de una matriz, por renglón.

Creamos una matriz de cuatro renglones.
```{r, echo=TRUE}
matriz <- matrix(1:14, nrow = 4) 
```

Aplicamos `apply()`, dando la función `sum()` el argumento `FUN`, nota que sólo necesitamos el nombre de la función, sin paréntesis.

Por último, damos el argumento `MARGIN = 1`, para aplicar la función por renglón.
```{r, echo=TRUE}
apply(X = matriz, MARGIN = 1, FUN = sum)
```

Esto es equivalente a hacer lo siguiente.
```{r, echo = TRUE}
sum(matriz[1, ])
sum(matriz[2, ])
sum(matriz[3, ])
sum(matriz[4, ])
```

Y naturalmente, es equivalente a hacer lo siguiente.
```{r}
sum(vector_1)
sum(vector_2)
sum(vector_3)
sum(vector_4)
```

**Estamos aplicando una función a cada elemento de nuestra matriz. Los elementos son los renglones. Cada renglón es un vector. Cada vector es usado como argumento de la función.**

Si cambiamos el argumento MARGIN de `MARGIN = 1` a `MARGIN = 2`, entonces la función se aplicará por columna.
```{r, echo=TRUE}
apply(X = matriz, MARGIN = 2, FUN = sum)
```

En este caso, la función `sum()` ha sido aplicado a cada elementos de nuestra matriz, los elementos son las columnas, y cada columna es un vector.

### ¿Qué es FUN?
FUN es un argumento que nos pide el **nombre de una función que se se aplicarla a todos los elementos de nuestra matriz**.

El ejemplo de la sección anterior aplicamos las funciones `mean()` y `sum()` usando sus nombres, sin paréntesis, esto es, sin especificar argumentos.

Podemos dar como argumento cualquier nombre de función, siempre y cuando esta acepte vectores como argumentos.

Probemos cambiando el argumento `FUN`. Usaremos la función `mean()` para obtener la media de cada renglón y de cada columna.

Aplicado a los renglones.
```{r, echo=TRUE}
apply(matriz, 1, mean)
```

Aplicado a las columnas
```{r, echo=TRUE}
apply(matriz, 2, mean)
```

Las siguientes llamadas a `sd()`, `max()` y `quantile()` se ejecutan sin necesidad de especificar argumentos.
```{r, echo=TRUE}
# Desviación estándar
apply(matriz, 1, FUN = sd)

# Máximo
apply(matriz, 1, FUN = max)

# Cuantiles
apply(matriz, 1, FUN = quantile)
```

## ¿Cómo sabe FUN cuáles son sus argumentos?
Recuerda que podemos llamar una función y proporcionar sus argumentos en orden, tal como fueron establecidos en su definición.

Por lo tanto, **el primer argumento que espera la función, sera la `X` del `apply()`**.

Para ilustrar esto, usaremos la función `quantile()`. Llama `?quantile` en la consola para ver su documentación.
```{r, echo=TRUE, eval=FALSE}
?quantile
```

`quantile()` espera siempre un argumento `x`, que debe ser un vector numerico, además tener varios argumentos adicionales. 

* `probs` es un vector numérico con las probabilidades de las que queremos extraer cuantiles.
* `na.rm`, si le asignamos `TRUE` quitará de x los `NA` y `NaN` antes de realizar operaciones. 
* `names`, si le asignamos `TRUE`, hará que el objeto resultado de la función tenga nombres. 
* `type` espera un valor entre 1 y 9, para determinar el algoritmo usado para el cálculo de los cuantiles.

En orden, el primer argumento es `x`, el segundo `probs`, y así sucesivamente.

Cuando usamos `quantile()` en un `apply()`, el argumento `x` de la función será cada elemento de nuestra matriz. Es decir, los vectores como renglones o columnas de los que está constituida la matriz.

Esto funcionará siempre y cuando los argumentos sean apropiados para la función. Si proporcionamos un argumento inválido, la función no se ejecutará y **apply** fallará.

Por ejemplo, intentamos obtener cuantiles de las columnas de una matriz, en la que una de ellas es de tipo caracter.

Creamos una matriz.
```{r, echo=TRUE}
matriz2 <- matrix(c(1:2, "a", "b"), nrow = 2)

# Resultado
```

Aplicamos la función y obtenemos un error.
```{r, echo=TRUE, error=TRUE}
apply(matriz2, 2, quantile)
```

Por lo tanto, **apply sólo puede ser usado con funciones que esperan vectores como argumentos**.

### ¿Qué pasa si deseamos utilizar los demás argumentos de una función con apply?
En los casos en los que una función tiene recibe más de un argumento, asignamos los valores de estos del nombre de la función, separados por comas, usando sus propios nombres (a este procedimiento es al que se refiere el argumento `...` descrito en la documentación de `apply`).

Supongamos que deseamos encontrar los cuantiles de un vector, correspondientes a las probabilidades **.33** y **.66**. Esto es definido con el argumento `probs` de esta función. 

Para ello, usamos `quantile()` y después de haber escrito el nombre de la función, escribimos el nombre del argumento probs y los valores que deseamos para este.
```{r, echo = TRUE}
apply(X = matriz, MARGIN = 2, FUN = quantile, probs = c(.33, .66))
```

Como podrás ver, hemos obtenido los resultados esperados.

Si además deseamos que el resultado aparezca sin nombres, entonces definimos el valor del argumento `names` de la misma manera.
```{r, echo=TRUE}
apply(matriz, 2, quantile, probs = c(.33, .66), names = FALSE)
```

De este modo es posible aplicar funciones complejas que aceptan múltiples argumentos, con la ventaja que usamos pocas líneas de código.

### ¿Qué tipo de resultados devuelve apply?
En los ejemplos anteriores, el resultado de `apply()` en algunas ocasiones fue un vector y en otros fue una matriz. 

Si aplicamos `mean()`, obtenemos como resultado un vector.
```{r, echo=TRUE}
mat_media <- apply(matriz, 1, mean)

class(mat_media)
```

Pero si aplicamos `quantile()`, obtenemos una matriz.
```{r, echo=TRUE}
mat_cuant <- apply(matriz, 1, quantile)

class(mat_cuant)
```

Este comportamiento se debe a que **`apply()` nos devolverá objetos del mismo tipo que la función aplicada devuelve**. Dependiendo de la función, será el tipo de objeto que obtengamos. 

Sin embargo, este comportamiento puede causarte algunos problemas. En primer lugar, anterior te obliga a conocer de antemano el tipo del resultado que obtendrás, lo cual no siempre es fácil de determinar, en particular si las funciones que estás utilizando son poco comunes o tienen comportamientos poco convencionales.

Cuando estás trabajando en proyectos en los que el resultado de una operación será usado en operaciones posteriores, corres el riesgo de que en alguna parte del proceso, un `apply()` te devuelva un resultado que te impida continuar adeñamte.

Con algo de práctica es más o menos sencillo identificar problemas posibles con los resultados de `apply()`, pero es algo que debes tener en cuenta, pues puede explicar porqué tu código no funciona como esperabas.

En este sentido, `lapply()` tiene la ventaja de que siempre devuelve una lista.

## lapply
`lapply()` es un caso especial de `apply()`, diseñado para **aplicar funciones a todos los elementos de una lista**. La **l** de su nombre se refiere, precisamente, a **lista**. 

`lapply()` intentará coercionar a una lista el objeto que demos como argumento y después aplicará una función a todos sus elementos. 

`lapply` siempre nos devolverá una lista como resultado. A diferencia de `apply`, sabemos que siempre obtendremos ub objeto de tipo lista después de aplicar una función, sin importar cuál función sea.

Dado que en R todas las estructuras de datos pueden coercionarse a una lista, `lapply()` puede usarse en un número más amplio de casos que `apply()`, además de que esto nos permite utilizar funciones que aceptan argumentos distintos a vectores.

La estructura de esta función es:
```{r, eval=FALSE}
lapply(X, FUN)
```

En donde:

* `X` es una lista o un objeto coercionable a una lista.
* `FUN` es la función a aplicar.

Estos argumentos son idéntico a los de `apply()`, pero a diferencia aquí no especificamos `MARGIN`, pues las listas son estructuras con una unidimensionales, que sólo tienen largo.

### Usando lapply()
Probemos `lapply()` aplicando una función a un data frame. Usaremos el conjunto de datos `trees`, incluido por defecto en R *base*.

`trees` contiene datos sobre el grueso, alto y volumen de distinto árboles de cerezo negro. Cada una de estas variables está almacenada en una columna del data frame.

Veamos los primeros cinco renglones de `trees`.
```{r, echo=TRUE}
trees[1:5, ]
```

Aplicamos la función `mean()`, usando su nombre.
```{r, echo=TRUE}
lapply(X = trees, FUN = mean)
```

Dado que un data frame esta formado por columnas y cada columna es un vector atómico, cuando usamos `lapply()` , la función es aplicada a cada columna. `lapply()`, a diferencia de `apply()` no puede aplicarse a renglones.

En este ejemplo, obtuvimos la media de grueso (Girth), alto (Height) y volumen (Volume), como una lista.

Verificamos que la clase de nuestro resultado es una lista con `class()`.
```{r, echo=TRUE}
arboles <- lapply(X = trees, FUN = mean)

class(arboles)
```

Esto es muy conveniente, pues la recomendacion para almacenar datos en un data frame es que cada columna represente una variable y cada renglón un caso (por ejemplo, el enfoque **tidy** de [Wickham (2014)](https://www.jstatsoft.org/article/view/v059i10/v59i10.pdf)). Por lo tanto,  con `lapply()` podemos manipular y transformar datos, por variable.

Al igual que con `apply()`, podemos definir argumentos adicionales a las funciones que usemos, usando sus nombres, después del nombre de la función.
```{r, echo=TRUE}
lapply(X = trees, FUN = quantile, probs = .8)
```

Si usamos `lapply` con una matriz, la función se aplicará a cada **celda** de la matriz, no a cada columna.

Creamos una matriz.
```{r, echo=TRUE}
matriz <- matrix(1:9, ncol = 3)

# Resultado
matriz
```

Llamamos a  `lapply()`.
```{r}
lapply(matriz, quantile, probs = .8)
```

Para usar una matriz con `lapply()` y que la función se aplique a cada columna, primero la coercionamos a un data frame con la función `as.data.frame()`
```{r, echo=TRUE}
lapply(as.data.frame(matriz), quantile, probs = .8)
```

Si deseamos aplicar una función a los renglones de una matriz, una manera de lograr es transponer la matriz con `t()` y después coercionar a un data frame.
```{r, echo=TRUE}
matriz_t <- t(matriz)

lapply(as.data.frame(matriz_t), quantile, probs = .8)
```

Con vectores como argumento, `lapply()` aplicará la función a cada elementos del vector, de manera similar a una vectorización de operaciones. 

Por ejemplo, usamos `lapply()` para obtener la raíz cuadrada de un vector numérico del 1 al 4, con la función `sqrt()`.
```{r, echo=TRUE}
mi_vector <- 1:4

lapply(mi_vector, sqrt)
```

### Usando lapply() en lugar de un bucle for
En muchos casos es posible reemplazar un bucle `for()` por un `lapply()`. 

De hecho, `lapply()` está haciendo lo mismo que un `for()`, está iterando una operación en todos los elementos de una estructura de datos.

Por lo tanto, el siguiente código con un `for()`...
```{r, echo=TRUE}
mi_vector <- 6:12
resultado <- NULL
posicion <- 1

for(numero in mi_vector) {
  resultado[posicion] <- sqrt(numero)
  posicion <- posicion + 1
}

resultado
```

... nos dará los mismos resultados que el siguiente código con `lapply()`.
```{r, echo=TRUE}
resultado <- NULL

resultado <- lapply(mi_vector, sqrt)

resultado
```

El código con `lapply()` es mucho más breve y más sencillo de entender, al menos para otros usuarios de R.

El inconveniente es que obtenemos una lista como resultado en lugar de un vector, pero eso es fácil de resolver usando la función `as.numeric()` para hacer coerción a tipo numérico.
```{r, echo=TRUE}
as.numeric(resultado)
```

El siguiente código es la manera en la que usamos `for()` si deseamos aplicar una función a todas sus columnas, tiene algunas partes que no hemos discutido, pero es sólo para ilustrar la diferencia simplemente usar `trees_max <- lapply(trees, max)`.
```{r, echo=TRUE}
trees_max <- NULL
i <- 1
columnas <- ncol(trees)

for(i in 1:columnas) {
  trees_max[i] <- max(trees[, i])
  i <- i +1
}

trees_max
```

### Usando lapply con listas
Hasta hora hemos hablado de usar `lapply()` con objetos que pueden coercionarse a una lista, pero ¿qué pasa si usamos esta función con una lista que contiene a otros objetos?

Pues la función se aplicará a cada uno de ellos. Por lo tanto, así podemos utilizar funciones que acepten todo tipo de objetos como argumento. Incluso podemos aplicar funciones a listas recursivas, es decir, listas de listas.

Por ejemplo, obtendremos el coeficiente de correlación de cuatro data frames contenidos en una sola lista. Esto no es posible con `apply()`, porque sólo podemos usar funciones que aceptan vectores como argumentos, pero con `lapply()` no es ningún problema.

Empezaremos creando una lista de data frames. Para esto, usaremos las función `rnorm()`, que genera números al azar y `set.seed()`, para que obtengas los mismos resultados aquí mostrados.

`rnorm()` creara `n` números al azar (pseudoaleatorios, en realidad), sacados de una distribución normal con media 0 y desviación estandar 1. `set.seed()` es una función que "fija" los resultados de una generación de valores al azar. Cada que ejecutas `rnorm()` obtienes resultados diferentes, pero si das un número como argumento `seed` a `set.seed()`, siempre obtendrás los mimos números.
```{r, echo = TRUE}
# Fijamos seed
set.seed(seed = 2018)

# Creamos una lista con tres data frames dentro
tablas <- list(
  df1 = data.frame(a = rnorm(n = 5), b = rnorm(n = 5), c = rnorm(n = 5)),
  df2 = data.frame(d = rnorm(n = 5), e = rnorm(n = 5), f = rnorm(n = 5)),
  df3 = data.frame(g = rnorm(n = 5), h = rnorm(n = 5), i = rnorm(n = 5))
)

# Resultado
tablas
```

Para obtener el coeficiente de correlación usaremos la función `cor()`. 

Esta función acepta como argumento una data frame o una matriz. Con este objeto, calculará el coeficiente de correlación **R de Pearson** existente entre cada una de sus columnas. Como resultado obtendremos una matriz de correlación.

Por ejemplo, este es el resultado de aplicar `cor()` a `iris`.
```{r, echo=TRUE}
cor(iris[1:4])
```

Con `lapply` aplicaremos `cor()` a cada uno de los data frames contenidos en nuestra lista. El resultado será una lista de matrices de correlaciones.

Esto lo logramos con una línea de código.
```{r, echo=TRUE}
lapply(X = tablas, FUN = cor)
```

De esta manera puedes manipular información de múltiples data frames, matrices o listas con muy pocas líneas de código y, en muchos casos, más rapidamente que con las alternativas existentes.

Finalmente, si asignamos los resultados de las última operación a un objeto, podemos usarlos y manipularlos de la misma manera que cualquier otra lista.

```{r, echo = TRUE}
correlaciones <- lapply(tablas, cor)

# Extraemos el primer elemento de la lista
correlaciones[[1]]
```

<!--chapter:end:10-apply.Rmd-->

# Importar y exportar datos
Hasta ahora, hemos trabajado con datos ya existentes en R *base* o que hemos generado nosotros mismos, sin embargo, lo usual es que usemos datos almacenados en archivos fuera de R.

R puede importar datos de una amplia variedad de tipos de archivo con las funciones en *base* además de que esta capacidad es ampliada con el uso de paquetes específicos.

Cuando importamos un archivo, estamos guardando su contenido en nuestra sesión como un objeto. Dependiendo del procedimiento que usemos será el tipo de objeto creado.

De manera análoga, podemos exportar nuestros objetos de R a archivos en nuestra computadora.

## Descargando datos
Antes de empezar a importar datos, vale la pena señalar que  podemos descargar archivos de internet usando R con la función `download.file()`.

De esta manera tendremos acceso a una vasta diversidad de fuentes de datos. Entre otras, podrás descargar los archivos 

La función `download.file()` nos pide como argumento `url`, la dirección de internet del archivo que queremos descargar y `destfile` el nbombre que tendrá el archivo en nuestra computadora. Ambos argumentos como cadenas de texto, es decir, entre comillas.

Por ejemplo, para descargar una copia del set *iris* disponible en el [*UCI Machine Learning Repository*](https://archive.ics.uci.edu) usamos la siguiente dirección como argumento `url`:

* https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data

Y asignamos "iris.data" al argumento `dest`.
```{r descarga iris, echo=TRUE, eval=FALSE}
download.file(
  url = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data", 
  destfile = "iris.data"
  )
```

El resultado es un archivo llamado "iris.data" en nuestro directorio de trabajo. 

Este método funciona con prácticamente todo tipo de archivos, aunque en algunos casos será necesario agregar el argumento `method = "wb"`, por asegurar que el archivo obtenido funcione correctamente.

## Tablas (datos rectangulares)
Como vimos en el capítulo [7](#estructuras-de-datos), las estructura rectangular, en renglones y columnas, es común y conveniente para el análisis de datos. Nos referiremos a esta forma de organizar datos como **tabla**.

R cuenta con la función genérica `read.table()`, que puede leer cualquier tipo de archivo que contenga una tabla. 

La condición para que R interprete un archivo como una tabla es que tenga renglones y en cada renglon, los datos estén separados por comas, o algún otro caracter, indicando columnas. Es decir, algo que luzca de la siguiente manera.

>1, 20,  8, 5

>1, 31,  6, 5

>2, 18,  9, 5

>2, 25, 10, 5

Por supuesto, en lugar de comas podemos tener puntos y coma, dos puntos, tabuladores o cualquier otro signo de puntuación como **separador** de columnas.

La función `read.table()` acepta un número considerable de argumentos. Los más importantes son los siguientes.

* `file`: La ruta del archivo que importaremos, como cadena de texto. Si el archivo se encuentra en nuestro [directorio de trabajo](##directorio-de-trabajo), es suficientedar el nombre del archivo, sin la ruta completa.
* `header`: Si nuestro archivo tiene encabezados, para ser interpretados como nombres de columna, definimos este argumento como `TRUE`.
* `sep`: El caracter que es usado como separador de columnas. Por defecto es ";".
* `col.names`: Un vector opcional, de tipo caracter, con los nombres de las columnas en la tabla.
* `stringsAsFactors`: Esta función convierte automáticamente los datos de texto a factores. Si este no es el comportamiento que deseamos, definimos este argumento como `FALSE`.

Puedes consultar todos los argumentos de esta función ejecutando `?read.table` en la consola.

Es importante señalar que el objeto obtenido al usar esta función es siempre un **data frame**.

Probemos con un archivo con extensión ".data", descargado desde el respositorio de [Github](http://www.github.com) de este libro. 
```{r descarga cancer.data, echo=TRUE, eval=FALSE}
download.file(
  url = "https://raw.githubusercontent.com/jboscomendoza/r-principiantes-bookdown/master/datos/breast-cancer-wis.data", 
  dest = "breast-cancer-wis.data"
)
```

Estos datos pertenecen a una base de diagnósticos de cancer mamario de la Universidad de Wisconsin, usado para probar métodos de aprendizaje automático. Puedes encontrar la información completa sobre este conjunto de datos en el siguiente enlace:

* https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+%28Diagnostic%29

Nos damos cuenta de que hemos tenido éxito en la descarga si aparece un mensaje en la consola de R indicando los resultados de nuesta operación.

Usamos sin especificar ningún otro argumento.
```{r read.table no args, echo=TRUE}
bcancer <- read.table(file = "breast-cancer-wis.data")
```

Veamos los primeros renglones de nuestros datos usando la función `head()`
```{r read.table no args head, echo=TRUE}
head(bcancer)
```

Nuestros datos no lucen particularmente bien. Necesitamos ajustar algunos parámetros al importarlos.

No hay datos de encabezado, por lo que `header` será igual a `FALSE` y  el separador de columnas es una coma, así que el valor de `sep` será ",". No conocemos cuál es el nombre de las columnas, así que por el momento no proporcionaremos uno.

```{r read.table args, echo=TRUE}
bcancer <- read.table(file = "breast-cancer-wis.data", header = FALSE, sep = ",")

# Resultado
head(bcancer)
```

Luce mejor, pero los nombres de las columnas son poco descriptivos. Si no damos nombres de variables, cada columna tendrá como nombre "V" seguida de números del 1 adelante.

Para este ejemplo, contamos con un archivo de información, que describe el contenido de los datos que hemos importado.

* https://raw.githubusercontent.com/jboscomendoza/r-principiantes-bookdown/master/datos/breast-cancer-wis.names

Si descargas este archivo, puedes abrirlo usando el bloc o navegador de internet de tu computadora.

Guardaremos en un vector las abreviaturas de los nombres de columna descritos en el documento anterior.
```{r nombres bcancer, echo=TRUE}
nombres <- c("id", "clump_t", "u_csize", "u_cshape", "m_adh", "spcs", "b_nuc", 
             "b_chr", "n_nuc", "mit", "class")
```

Ahora usaremos este vector como argumento `col.names` en `read.table()`, para importar nuestros datos con nombres de columna.
```{r, echo=TRUE}
bcancer <- read.table(file = "breast-cancer-wis.data", header = FALSE, sep = ",",
                      col.names = nombres)

# Resultado
head(bcancer)
```

Nuestros datos han sido importados correctamente. Además, el objeto resultante es un data frame, listo para que trabajemos con él.
```{r, echo=TRUE}
class(bcancer)
```

### Archivos CSV
Un caso particular de las tablas, son los archivos separados por comas, con extensión **.csv**, por *Comma Separated Values*, sus siglas en inglés. Este es un tipo de archivo comunmente usado para compartir datos, pues es compatible con una amplia variedad de sistemas diferentes además de que ocupa relativamente poco espacio de almacenamiento.

Este tipo de archivos también se pueden importar usando la función `read.table()`.

Probemos descargando los mismos datos que en el ejemplo anterior, pero almacenados en un archivo con extensión **.csv**.
```{r, echo=TRUE, eval=FALSE}
download.file(
  url = "https://raw.githubusercontent.com/jboscomendoza/r-principiantes-bookdown/master/datos/breast-cancer-wis.csv", 
  dest = "breast-cancer-wis.csv"
)
```

Podemos usar `read.table()` con los mismos argumentos que en el ejemplo anterior, con la excepción de que este archivo sí tiene encabezados de columna, por lo que cambiamos `header` de `FALSE` a `TRUE`.
```{r, echo=TRUE}
bcancer <- read.table(file = "breast-cancer-wis.csv", header = TRUE, sep = ",",
                      col.names = nombres)

# Resultado
head(bcancer)
```

Una ventaja de usar documentos con extensión **.csv** es la posibilidad de usar la función `read.csv()`. Esta es una es una versión de `read.table()`, optimizada para importar archivos **.csv**.

`read.csv()` acepta los mismos argumentos que `read.table()`, pero al usarla con un archivo **.csv**, en casi todo los casos, no hara falta especificar nada salvo la ruta del archivo.
```{r, echo=TRUE}
bcancer <- read.csv("breast-cancer-wis.csv")

# Resultado
head(bcancer)
```

`read.csv()` también devuelve un data frame como resultado

## Exportar datos
Algo muy importante en trabajar con R es exportar los datos que hemos generado. 

Dependiendo del tipo de estructura de dato en el que se encuentran contenidos nuestros datos son las opciones que tenemos para exportarlos.


### Data frames y matrices
Si nuestros datos se encuentran contenidos en una estructura de datos rectangular, podemos exportarlos con diferentes funciones.

De manera análoga a `read.table()`, la función `write.table()` nos permite exportar matrices o data frames, como archivos de texto con distintas extensiones.

Los argumentos más usados de `write.table()` son los siguientes.

* `x`:  El nombre del data frame o matriz a exportar.
* `file`: El nombre, extensión y ruta del archivo creado con esta función. Si sólo escribimos el nombre del archivo, este será creado en nuestro directorio de tabajo.
* `sep`: El caracter que se usará como separador de columnas.
* `row.names`: Si deseamos incluir el nombre de los renglones en nuestro objeto al exportarlo, establecemos este argumento como `TRUE`. En general, es recomendable fijarlo como `FALSE`, para conservar una estructura tabular más fácil de leer.
* `col.names`: Si deseamos que el archivo incluya los nombres de las columnas en nuestro objeto, establecemos este argumento como `TRUE`. Es recomendable fijarlo como `TRUE` para evitar la necesidad de almacenar los nombres de columna en documentos distintos.

Puedes consultar todos los argumentos de esta función ejecutando `?write.table`.

Probemos exportando el objeto `iris` a un documento de texto llamado **iris.txt** a nuestro directorio de trabajo, usando como separador la coma, con nombres de columnas y sin nombre de renglones. 
```{r write.table, echo=T}
write.table(x = iris, file = "iris.txt", sep = ",", 
            row.names = FALSE, col.names = TRUE)
```

Importemos el archivo que hemos creado usando `read.table()`.
```{r exportar iris.txt, echo=TRUE}
iris_txt <- read.table(file = "iris.txt", header = TRUE, sep = ",")

# Resultado
head(iris_txt)
```

También podemos exportar datos a archivos con extensión **.csv** con la función `write.csv()`. 

Vamos a exportar `iris` como un documento **.csv**. En este caso, sólo especificamos que no deseamos guardar los nombres de los renglones con `row.names = FALSE`.
```{r exportar iris.csv, echo=TRUE}
write.csv(x = iris, file = "iris.csv", row.names = FALSE) 
```

Importamos el archivo creado.
```{r importar iris.csv, echo=TRUE}
iris_csv <- read.csv("iris.csv")

# Resultado
head(iris_csv)
```

### Listas
La manera más sencilla de exportar listas es guardarlas en archivos RDS. Este es un tipo de archivo nativo de R que puede almacenar cualquier objeto a un archivo en nuestro disco duro. 

Además, RDS comprime los datos que almacena, por lo que ocupa menos espacio en disco duro que otros tipos de archivos, aunque contengan la misma información.

Para exportar un objeto a un archivo RDS, usamos la función `saveRDS()` que siempre nos pide dos argumentos:

* `object`: El nombre del objeto a exportar.
* `file`: El nombre y ruta del archivo que crearemos. Los archivos deben tener la extensión **.rds**. Si no especificamos una ruta completa, el archivo será creado en nuestro directorio de trabajo.

Creamos una lista de ejemplo que contiene dos vectores y dos matrices
```{r lista a exportar, echo = TRUE}
mi_lista <- list("a" = c(TRUE, FALSE, TRUE),
     "b" = c("a", "b", "c"),
     "c" = matrix(1:4, ncol = 2),
     "d" = matrix(1:6, ncol = 3))


# Resultado
mi_lista
```

Aunque podemos intentar `write.table()` para exportar listas, por lo general obtendremos un error como resultado.

Tratamos de exportar la lista anterior como un archivo **.txt**.
```{r lista intento write.table, echo = TRUE, error=TRUE}
write.table(x = mi_lista, file = "mi_lista.txt")
```

Usamos la función `saveRDS()` para exportar al archivo **mi_lista.rds**.
```{r exportar rds, echo = TRUE}
saveRDS(object = mi_lista, file = "mi_lista.rds")
```

Si deseamos importar un archivo RDS a R, usamos la función `readRDS()`, indicando la ruta en la que se encuentra el archivo que deseamos.

Intentemos importar el archivo **mi_lista.rds**.
```{r importar rds, echo=TRUE}
mi_lista_importado <- readRDS(file = "mi_lista.rds")
```

Vamos el resultado.
```{r resultado rds, echo=TRUE}
mi_lista_importado

# El resultado es una lista, al igual que el objeto original
class(mi_lista)
```

Los objetos immportados usando un archivo RDS conservan los tipos y clases que tenían originalmente, lo cual previene pérdida de información.

## Hojas de cálculo de Excel
Un formato usado con mucha frecuencia para almacenar archivos son las hojas de cálculo, en particular las generadas por el paquete [*Microsoft Excel*](https://products.office.com/es-mx/excel).

R *base* no tiene una función para importar archivos almacenados en archivos con extensión **.xsl** y **.xslx**, creados con *Excel*.

Para importar datos desde este tipo de archivos, necesitamos instalar el paquete **readxl**, que contiene funciones específicas para realizar esta tarea.

Usamos la función `installpackages()`, como lo vimos en el [capítulo 3](##paquetes)
```{r instalar readxl, echo =TRUE, eval=FALSE}
install.packages("readxl")
```

Ya instalado, cargamos el **readxl** a nuestra sesión de trabajo.
```{r, echo=TRUE}
library(readxl)
```

Usaremos, principalmente dos funciones de este paquete.

* `read_excel()`: Para importar archivos **.xls** y **xlsx**.
* `excel_sheets()`: Para obtener los nombres de las pestañas en una hoja de cálculo de *Excel*.

Para probar estas funciones, descargaremos una hoja de cálculo de prueba. Nota que hemos establecido el argumento `mode = "wb"` para asegurar que el archivo se descargue correctamente.
```{r descarga xlsx, echo=TRUE, eval=FALSE}
download.file(
  url = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris/data_frames.xlsx", 
  destfile = "data_frames.xlsx", 
  mode = "wb"
) 
```

Si intentamos leer las primeras cinco líneas de **data_frames.xlsx**, confirmamos que este es un archivo que no tiene forma rectangular, de tabla.
```{r readLines xlsx, echo = TRUE}
readLines("data_frames.xlsx", n = 5)
```

En caso de que tengamos instalado *Excel* o algún otro programa compatible con archivos de hoja de cálculo, como *LibreOffice Calc* o *Number*, podemos pedir a R que abra este archivo con `file.show()`. De este modo podemos explorar su contenido.
```{r show.file xlsx, echo=TRUE, eval=FALSE}
file.show("data_frames.xlsx")
```

La función `excel_sheets()` nos devuelve el nombre de las pestañas como un vector.
```{r excel_sheets, echo=TRUE}
excel_sheets("data_frames.xlsx")
```

Este archivo tiene dos pestañas, llamadas **iris** y **trees**. 

Intentaremos importar la pestaña **iris** con `read_excel()`. Esta función tiene los siguientes argumentos principales. 

* `path`: La ruta del archivo a importar. Si no especificamos una ruta completa, será buscado en nuestro directorio de trabajo.
* `sheet`: El nombre de la pestaña a importar. Si no especificamos este argumento, `read_excel()` intentará leer la primera pestaña de la hoja de cálculo.
* `range`: Cadena de texto con el rango de celdas a importar, escrito con el formato usado en *Excel*. Por ejemplo, "A1:B:10".
* `col_names`: Si la pestaña que vamos a importar tiene encabezados, definimos este argumento como `TRUE` para usarlos como nombre de columna. Si no tenemos encabezados, podemos dar un vector con los nombres que queremos asignar a las columnas, uno para cada columna.

Puedes consultar todos los argumentos de esta función ejecutando `?read_excel`.

Probemos `read_excel()`.
```{r read_excel iris, echo=TRUE, eval=FALSE}
iris_excel <- read_excel(path = "data_frames.xlsx", sheet = "iris")
```

Nuestro resultado es un data frame.
```{r iris_excel, echo=TRUE}
iris_excel
```



`read_excel()` funciona mejor

## Archivos con una estructura desconocida
Habrá ocasiones en las que no estamos seguros del contenido de los archivos que deseamos importar. En estos casos, podemos pedirle a R que intente abrir el archivo en cuestión, usando la función `file.show()`.

Por ejemplo, intentamos abrir el archivo con extensión **.csv** que importamos antes.
```{r, echo=TRUE, eval=FALSE}
show.file("breast-cancer-wis.csv")
```

R intentará usar el programa que en nuestro equipo, por defecto, abre el tipo de archivo que le hemos indicado. Si no tenemos un programa configurado para abrir el tipo de archivo que deseamos, nuestro sistema operativo nos pedira que elijamos uno.

Lo anterior puede ocurrir si intentas abrir el archivo con extensión **.data** que hemos importado en este capítulo.
```{r, echo=TRUE, eval=FALSE}
show.file("breast-cancer-wis.data")
```

Podemos usar la función `readLines()` para leer un archivo línea por línea. Establecemos el argumento `n = 4` para obtener sólo los primeros cuatro renglones del documento.
```{r, echo = TRUE}
readLines("breast-cancer-wis.data", n = 4)
```

La salida es una lista de vectores, uno por linea en el archivo. 

Observando la salida de `readLines()` podremos determinar si el archivo que nos interesa puede ser importado usando con los métodos que hemos revisado o necesitaremos de herramientas diferentes.

El documento "R Data Import/Export" (R Core Team, 2018) contiene una guía avanzada sobre el proceso de importar y exportar todo tipo de datos. Puedes consultarlo en el siguiente enlace:

* https://cran.r-project.org/doc/manuals/r-release/R-data.pdf

## El paquete readr

### Importar
read_csv
read_lines
read_fwf
read_rds

### Exportar
write_csv
write_rds

## SPSS, SAS y Stata
library(haven)

### Importar
read_spss
read_sas
read_stata

### Exportar
write_spss
write_sas
write_stata








<!--chapter:end:11-importar-y-exportar.Rmd-->

